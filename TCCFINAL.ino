
//Projeto de Conclusão de Curso - Eletrônica 3ºC
//By: Pedro Antônio da Nóbrega Silva



// Biliotecas
#include <Wire.h>                 //Incluida
#include <DS3232RTC.h>            //Download:
#include <TimeLib.h>              //Download:
#include <MCUFRIEND_kbv.h>        //Download:
#include <Adafruit_GFX.h>         //Download:
#include <TouchScreen.h>          //Download:
#include <Fonts/FreeSans9pt7b.h>  //Download:
#include <EEPROM.h>               // Incluida
#include <SPI.h>                  // Incluida
#include <SD.h>                   // Incluida

// Definições do hardware
#define YP A1
#define XM A2
#define YM 7
#define XP 6
#define SCREEN_WIDTH 480
#define SCREEN_HEIGHT 320
#define TS_MINX 957  // vem do LEFT em landscape
#define TS_MAXX 163  // vem do RT em landscape
#define TS_MINY 167  // vem do BOT em landscape
#define TS_MAXY 969  // vem do TOP em landscape
#define LCD_RS A2
#define LCD_WR A1
#define LCD_RD A0
#define LCD_RESET A4
#define LCD_CS A3
#define MINPRESSURE 10
#define MAXPRESSURE 1000

//Definição da endereço do EEPROM
#define ADDR_ALARME1 1
#define ADDR_ALARME2 2
#define ADDR_ALARME3 3
#define ADDR_ALARME4 4
#define ADDR_ALARME5 5
#define ADDR_ALARME6 6
#define ADDR_DELALARM1 7
#define ADDR_DELALARM2 8
#define ADDR_DELALARM3 9
#define ADDR_DELALARM4 10
#define ADDR_DELALARM5 11
#define ADDR_DELALARM6 12
#define ADDR_TEXTO1 100
#define ADDR_TEXTO2 200
#define ADDR_TEXTO3 300
#define ADDR_TEXTO4 400
#define ADDR_TEXTO5 500
#define ADDR_TEXTO6 600
#define ADDR_HORA1 700
#define ADDR_MIN1 701
#define ADDR_HORA2 710
#define ADDR_MIN2 711
#define ADDR_HORA3 720
#define ADDR_MIN3 721
#define ADDR_HORA4 730
#define ADDR_MIN4 731
#define ADDR_HORA5 740
#define ADDR_MIN5 741
#define ADDR_HORA6 750
#define ADDR_MIN6 751
#define ADDR_CICLO_ALARME1 760
#define ADDR_CICLO_ALARME2 761
#define ADDR_CICLO_ALARME3 762
#define ADDR_CICLO_ALARME4 763
#define ADDR_CICLO_ALARME5 764
#define ADDR_CICLO_ALARME6 765
#define ADDR_RTC_DIA 780
#define ADDR_RTC_MES 781
#define ADDR_RTC_ANO 782
#define ADDR_RTC_HORA 783
#define ADDR_RTC_MIN 784
uint8_t ALARME1, ALARME2, ALARME3, ALARME4, ALARME5, ALARME6;
uint8_t DELALARM1, DELALARM2, DELALARM3, DELALARM4, DELALARM5, DELALARM6;
byte horasAlarme[6];
byte minutosAlarme[6];
bool jaInicializouHorario1 = false;
bool jaInicializouHorario2 = false;
bool jaInicializouHorario3 = false;
bool jaInicializouHorario4 = false;
bool jaInicializouHorario5 = false;
bool jaInicializouHorario6 = false;

String textoDigitado;
int alarmeEditando = 0;

uint8_t cicloAlarme[6];
const char* letrasTeclado[26] = {
  "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
  "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
  "U", "V", "W", "X", "Y", "Z"
};

// Cores
#define WHITE 0x0000
#define BLUE 0x001F
#define RED 0xF800
#define GREEN 0x07E0
#define CYAN 0x07FF
#define MAGENTA 0xF81F
#define YELLOW 0xFFE0
#define BLACK 0xFFFF

#define RGB(r, g, b) (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3))

#define GREY RGB(127, 127, 127)
#define DARKGREY RGB(64, 64, 64)
#define TURQUOISE RGB(0, 128, 128)
#define PINK RGB(255, 128, 192)
#define OLIVE RGB(128, 128, 0)
#define PURPLE RGB(128, 0, 128)
#define AZURE RGB(0, 128, 255)
#define ORANGE RGB(255, 108, 44)
#define LIGHTGREY RGB(192, 192, 192)
#define DARKBLUE RGB(0, 0, 139)
#define LIGHTBLUE RGB(173, 216, 230)
#define NAVY RGB(0, 0, 128)
#define TEAL RGB(0, 128, 128)
#define LIME RGB(0, 255, 0)
#define DARKGREEN RGB(0, 100, 0)
#define LIGHTGREEN RGB(144, 238, 144)
#define BROWN RGB(139, 69, 19)
#define MAROON RGB(128, 0, 0)
#define BEIGE RGB(185, 200, 220)
#define SALMON RGB(250, 128, 114)
#define CORAL RGB(255, 127, 80)
#define GOLD RGB(255, 215, 0)
#define SILVER RGB(192, 192, 192)
#define INDIGO RGB(75, 0, 130)
#define VIOLET RGB(238, 130, 238)
#define SKYBLUE RGB(135, 206, 235)
#define CHOCOLATE RGB(210, 105, 30)



//Definição dos préfixos
DS3232RTC RTC;
#define BUFFPIXEL 10  // tamanho do buffer para leitura do bitmap
MCUFRIEND_kbv tft;
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 300);  // XP = 6, YP = 55, XM = 56, YM = 7


//Bitmaps
const unsigned char info[] PROGMEM = {
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x06, 0xc0, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x06, 0xc0, 0x00, 0x3f, 0xff, 0xf8, 0x00,
  0x06, 0xc0, 0x00, 0xff, 0x83, 0xfc, 0x00, 0x06, 0xc0, 0x01, 0xf8, 0x00, 0x3f, 0x00, 0x06, 0xc0,
  0x07, 0xc0, 0x00, 0x07, 0x80, 0x06, 0xc0, 0x0f, 0x80, 0x38, 0x03, 0xe0, 0x06, 0xc0, 0x1e, 0x00,
  0xfc, 0x00, 0xf0, 0x06, 0xc0, 0x3c, 0x00, 0xfe, 0x00, 0x78, 0x06, 0xc0, 0x78, 0x01, 0xfe, 0x00,
  0x38, 0x06, 0xc0, 0x70, 0x01, 0xff, 0x00, 0x1c, 0x06, 0xc0, 0xe0, 0x01, 0xfe, 0x00, 0x0e, 0x06,
  0xc1, 0xc0, 0x00, 0xfe, 0x00, 0x0e, 0x06, 0xc1, 0xc0, 0x00, 0x7c, 0x00, 0x07, 0x06, 0xc3, 0x80,
  0x00, 0x38, 0x00, 0x07, 0x06, 0xc3, 0x80, 0x00, 0x00, 0x00, 0x03, 0x86, 0xc3, 0x80, 0x00, 0x38,
  0x00, 0x03, 0x86, 0xc7, 0x00, 0x00, 0x7c, 0x00, 0x01, 0x86, 0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01,
  0xc6, 0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc6,
  0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc6, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc6, 0x00, 0x00,
  0xfe, 0x00, 0x01, 0xc6, 0xc6, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc6, 0x00, 0x00, 0xfe, 0x00,
  0x01, 0xc6, 0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6,
  0xc7, 0x00, 0x00, 0xfe, 0x00, 0x01, 0xc6, 0xc3, 0x00, 0x00, 0xfe, 0x00, 0x01, 0x86, 0xc3, 0x80,
  0x00, 0xfe, 0x00, 0x03, 0x86, 0xc3, 0x80, 0x00, 0xfe, 0x00, 0x03, 0x86, 0xc3, 0x80, 0x00, 0xfe,
  0x00, 0x07, 0x06, 0xc1, 0xc0, 0x00, 0xfe, 0x00, 0x07, 0x06, 0xc0, 0xe0, 0x00, 0xfe, 0x00, 0x0e,
  0x06, 0xc0, 0xe0, 0x00, 0xfe, 0x00, 0x1e, 0x06, 0xc0, 0x70, 0x00, 0xfe, 0x00, 0x1c, 0x06, 0xc0,
  0x78, 0x00, 0xfe, 0x00, 0x38, 0x06, 0xc0, 0x3c, 0x00, 0xfe, 0x00, 0x70, 0x06, 0xc0, 0x1e, 0x00,
  0x7c, 0x01, 0xe0, 0x06, 0xc0, 0x0f, 0x80, 0x10, 0x03, 0xc0, 0x06, 0xc0, 0x03, 0xe0, 0x00, 0x0f,
  0x80, 0x06, 0xc0, 0x01, 0xf8, 0x00, 0x7f, 0x00, 0x06, 0xc0, 0x00, 0x7f, 0xff, 0xfc, 0x00, 0x06,
  0xc0, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x06, 0xc0, 0x00, 0x03, 0xff, 0x80, 0x00, 0x06, 0xc0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x60, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0c, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xe0
};

const uint16_t back[] PROGMEM = {
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xb5b6, 0x7bcf, 0x3186, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3186, 0x7bcf,
  0xb5b6, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc638, 0x31a6, 0x0000, 0x0000, 0x0000,
  0x0861, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082,
  0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082,
  0x1082, 0x1082, 0x1082, 0x1082, 0x0861, 0x0000, 0x0000, 0x0000, 0x39c7, 0xc638, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0x7bef, 0x0020, 0x0000, 0x3186, 0x94b2, 0xd69a, 0xef5d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d,
  0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d,
  0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef5d, 0xd69a, 0x94b2, 0x2965, 0x0000,
  0x0020, 0x7bef, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7bef, 0x0000, 0x0841, 0x8c51, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0x8430, 0x0841, 0x0000, 0x8410, 0xffff, 0xffff, 0xffff, 0xb5b6, 0x0000, 0x0020,
  0xad75, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0020,
  0x0000, 0xbdd7, 0xffff, 0xffff, 0x39c7, 0x0000, 0x9492, 0xffff, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0x8c71, 0x0000, 0x39c7, 0xffff, 0xb596, 0x0000, 0x39c7, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0x31a6, 0x0000,
  0xbdd7, 0x738e, 0x0000, 0x9cd3, 0xffff, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0x94b2, 0x0000, 0x73ae, 0x3186, 0x0000, 0xd69a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xd69a, 0x0000, 0x39c7, 0x0841,
  0x0841, 0xef7d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xef5d, 0x0841, 0x0841, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xdefb, 0xad75, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x1082,
  0x2104, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xef5d, 0x5aeb, 0x0000, 0x0000, 0x2945, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x18e3, 0x0000, 0x0020, 0x0000, 0x2124, 0xffdf,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e,
  0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef7d, 0x630c,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2945, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xb596, 0x2104, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2945, 0xffdf, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000,
  0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef7d, 0x632c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x2124, 0xef5d, 0xf79e, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d,
  0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xf79e, 0xf7be, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xb5b6,
  0x2104, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082,
  0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x0861, 0x10a2, 0x2124, 0x3186, 0x4208, 0x6b4d,
  0xa514, 0xe73c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861,
  0xf79e, 0xffff, 0xffff, 0xffff, 0xef7d, 0x6b4d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1082, 0x630c, 0xce79, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xbdd7, 0x2124, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x0000,
  0x0000, 0x0020, 0x630c, 0xef5d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf7be, 0xf7be,
  0x6b4d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2104, 0xd69a, 0xffff, 0xffff, 0xffff, 0xffff,
  0xf79e, 0x0861, 0x0000, 0x0000, 0x0841, 0xffff, 0xc638, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0020, 0x0000, 0x18c3, 0xd6ba, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xc638, 0x2965,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x31a6, 0xf7be, 0xffff, 0xffff, 0xf79e, 0x0861,
  0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xf7be, 0x738e, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x7bcf, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xbdf7,
  0x2945, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0841, 0xd6ba, 0xffff, 0xef7d, 0x0861, 0x0000, 0x0000,
  0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x738e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0861, 0x630c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c, 0x632c,
  0x632c, 0x632c, 0x632c, 0x5aeb, 0x4a49, 0x2945, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020,
  0x0000, 0x73ae, 0xffff, 0xef7d, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xbdf7, 0x2124, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2945, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xd6ba, 0x8410, 0x1082,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2945, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x6b6d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x2124, 0xf7be, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc618, 0x0841, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020,
  0xdedb, 0xffdf, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xbdd7, 0x2124, 0x0000, 0x0000, 0x0000, 0x0000, 0x2945, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0x73ae, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xad75, 0xffff, 0x0841, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef7d, 0x6b4d, 0x0000, 0x0000, 0x0000, 0x2945, 0xffdf,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xbdf7, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x8c51, 0xffff,
  0x0841, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xb5b6, 0x2104, 0x0000, 0x2124, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe71c, 0x0841, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x8410, 0xffff, 0x0841, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x5aeb, 0x31a6, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xdefb, 0x0841, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000, 0x8410, 0xffff, 0x0841, 0x0000,
  0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffdf, 0xef7d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0xad55, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0020, 0x0000, 0x9492, 0xffff, 0x0841, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0x4208, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xbdd7, 0xffff, 0x0841, 0x0000, 0x0000, 0x0861,
  0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7be, 0x632c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0861, 0xef5d, 0xf7be, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffdf, 0xd6ba, 0xd69a, 0xd69a, 0xd69a, 0xd69a, 0xd69a, 0xd69a, 0xd69a, 0xd69a, 0xb5b6, 0x8410, 0x2945, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4a69, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xbdd7, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
  0x0020, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa534, 0xffff,
  0xef7d, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x3186, 0xffdf, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xbdf7, 0xffff, 0xffff, 0xf79e, 0x0861,
  0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x8c51, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8430, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000,
  0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x10a2, 0xa534, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xad75, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0020, 0x630c, 0xe71c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xad75, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x18c3, 0x4a49, 0x8410, 0xd6ba, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xf79e, 0x0861, 0x0000, 0x0000, 0x0861, 0xf79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xe71c, 0x8410, 0x8410, 0x8410, 0x8410, 0x8410, 0x8410, 0x7bef, 0x8430, 0x9492, 0xad55, 0xce59, 0xf79e, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x0861, 0x0000, 0x0841, 0x0841, 0xef5d, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef5d,
  0x0841, 0x0841, 0x31a6, 0x0000, 0xd69a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf,
  0xffdf, 0xffdf, 0xffdf, 0xffdf, 0xffdf, 0xffdf, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xce79, 0x0000, 0x39c7, 0x738e, 0x0000, 0x9cd3, 0xffff, 0xffdf, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0x94b2, 0x0000, 0x73ae,
  0xbdd7, 0x0000, 0x39c7, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0x39c7, 0x0000, 0xbdd7, 0xffff, 0x39c7, 0x0000, 0x9cd3, 0xffff, 0xffdf, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xffff, 0x94b2, 0x0000, 0x39e7, 0xffff, 0xffff, 0xbdd7,
  0x0000, 0x0841, 0xb596, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xb596, 0x0841, 0x0000, 0xbdd7, 0xffff, 0xffff, 0xffff, 0x8410, 0x0000, 0x0841, 0x8c51, 0xf7be, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7be, 0x8c51, 0x0841, 0x0000, 0x8410, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x7bef,
  0x0020, 0x0000, 0x3186, 0x94b2, 0xd69a, 0xef5d, 0xf79e, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d,
  0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d,
  0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xef7d, 0xe73c, 0xd69a, 0x94b2, 0x2965, 0x0000, 0x0020, 0x7bef,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc638, 0x31a6, 0x0000, 0x0000, 0x0000, 0x0861, 0x1082, 0x1082, 0x1082,
  0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082,
  0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082, 0x1082,
  0x0861, 0x0000, 0x0000, 0x0000, 0x31a6, 0xc638, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf,
  0xb5b6, 0x7bcf, 0x3186, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3186, 0x7bcf, 0xb5b6, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff
};
const unsigned char certo[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00,
  0x3f, 0xff, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x03, 0xff,
  0xff, 0xfc, 0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x0f, 0xff, 0xff,
  0xff, 0x00, 0x1f, 0xff, 0xff, 0xdf, 0x80, 0x1f, 0xff, 0xff, 0x87, 0x80, 0x3f, 0xff, 0xff, 0x07,
  0xc0, 0x3f, 0xff, 0xfe, 0x07, 0xc0, 0x3f, 0xff, 0xfc, 0x07, 0xc0, 0x3f, 0xff, 0xf8, 0x0f, 0xe0,
  0x3f, 0xff, 0xf0, 0x1f, 0xe0, 0x7f, 0xff, 0xe0, 0x3f, 0xe0, 0x7e, 0x3f, 0xc0, 0x7f, 0xe0, 0x3c,
  0x1f, 0x80, 0xff, 0xe0, 0x3c, 0x0f, 0x01, 0xff, 0xe0, 0x3c, 0x06, 0x03, 0xff, 0xc0, 0x3e, 0x00,
  0x07, 0xff, 0xc0, 0x3f, 0x00, 0x0f, 0xff, 0xc0, 0x1f, 0x80, 0x1f, 0xff, 0x80, 0x1f, 0xc0, 0x3f,
  0xff, 0x80, 0x0f, 0xe0, 0x7f, 0xff, 0x00, 0x0f, 0xf0, 0xff, 0xff, 0x00, 0x07, 0xf9, 0xff, 0xfe,
  0x00, 0x03, 0xff, 0xff, 0xfc, 0x00, 0x01, 0xff, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00,
  0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
const unsigned char termometroquente[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x84, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x01, 0x02, 0x00, 0x00, 0x03, 0x60, 0x00,
  0x02, 0x02, 0x00, 0x00, 0x06, 0x30, 0x00, 0x02, 0x02, 0x00, 0x00, 0x04, 0x10, 0x00, 0x02, 0x02,
  0x00, 0x00, 0x0c, 0x08, 0x00, 0x02, 0x02, 0x00, 0x00, 0x08, 0x8c, 0x00, 0x02, 0x02, 0x00, 0x00,
  0x19, 0xc4, 0x00, 0x02, 0x02, 0x00, 0x00, 0x31, 0xc6, 0x00, 0x02, 0x02, 0x00, 0x00, 0x30, 0xc2,
  0x00, 0x02, 0x02, 0x00, 0x00, 0x60, 0xc1, 0x00, 0x02, 0x02, 0x00, 0x00, 0x40, 0xc1, 0x80, 0x02,
  0x7a, 0x00, 0x00, 0xc0, 0xc0, 0x80, 0x02, 0x7a, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0x02, 0x7a, 0x00,
  0x01, 0x80, 0xc0, 0x40, 0x02, 0x7a, 0x00, 0x03, 0x00, 0x80, 0x60, 0x02, 0x7a, 0x00, 0x02, 0x00,
  0x00, 0x30, 0x02, 0x7a, 0x00, 0x06, 0x00, 0xc0, 0x10, 0x02, 0x7a, 0x00, 0x04, 0x01, 0xc0, 0x18,
  0x02, 0x7a, 0x00, 0x0c, 0x00, 0x80, 0x08, 0x02, 0x7a, 0x00, 0x0c, 0x00, 0x00, 0x08, 0x02, 0x7a,
  0x00, 0x06, 0x00, 0x00, 0x18, 0x02, 0x7a, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x02, 0x7a, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x7a, 0x00, 0x00, 0x00, 0x60, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x02,
  0x7a, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x02, 0x7a, 0x00,
  0x00, 0x03, 0xe0, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x07,
  0xf0, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x07, 0xfc, 0x00,
  0x02, 0x7a, 0x00, 0x00, 0x37, 0xfc, 0x00, 0x02, 0x7a, 0x00, 0x00, 0x37, 0xfe, 0x00, 0x02, 0x7b,
  0x00, 0x00, 0x7f, 0xff, 0x00, 0x06, 0xf9, 0x80, 0x00, 0x7f, 0x7f, 0x00, 0x0d, 0xfc, 0xc0, 0x00,
  0xff, 0x3f, 0x80, 0x1b, 0xff, 0x40, 0x00, 0xfe, 0x3f, 0x80, 0x17, 0xff, 0x60, 0x00, 0xfe, 0x1f,
  0x80, 0x17, 0xff, 0xa0, 0x00, 0xfe, 0x1f, 0xc0, 0x2f, 0xff, 0xa0, 0x00, 0xfe, 0x0f, 0x80, 0x2f,
  0xff, 0xa0, 0x00, 0xf0, 0x07, 0x80, 0x2f, 0xff, 0xa0, 0x00, 0x70, 0x07, 0x80, 0x37, 0xff, 0xa0,
  0x00, 0x78, 0x07, 0x00, 0x17, 0xff, 0xe0, 0x00, 0x38, 0x06, 0x00, 0x1b, 0xff, 0x40, 0x00, 0x18,
  0x04, 0x00, 0x0d, 0xfe, 0xc0, 0x00, 0x08, 0x08, 0x00, 0x06, 0xf9, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
};
const unsigned char termometrofrio[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x01, 0x8c, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x03, 0x06, 0x00, 0x00, 0x03, 0x60, 0x00,
  0x02, 0x02, 0x00, 0x00, 0x06, 0x30, 0x00, 0x02, 0x02, 0x00, 0x00, 0x04, 0x18, 0x00, 0x02, 0x02,
  0x00, 0x00, 0x0c, 0x08, 0x00, 0x02, 0x02, 0x00, 0x00, 0x08, 0x8c, 0x00, 0x02, 0x02, 0x00, 0x00,
  0x18, 0xc4, 0x00, 0x02, 0x02, 0x00, 0x00, 0x10, 0xc6, 0x00, 0x02, 0x02, 0x00, 0x00, 0x30, 0xc3,
  0x00, 0x02, 0x02, 0x00, 0x00, 0x60, 0xc1, 0x00, 0x02, 0x02, 0x00, 0x00, 0x40, 0xc1, 0x80, 0x02,
  0x02, 0x00, 0x00, 0xc0, 0xc0, 0x80, 0x02, 0x02, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0x02, 0x02, 0x00,
  0x01, 0x80, 0xc0, 0x40, 0x02, 0x02, 0x00, 0x03, 0x00, 0x80, 0x60, 0x02, 0x02, 0x00, 0x02, 0x00,
  0x00, 0x30, 0x02, 0x02, 0x00, 0x06, 0x00, 0xc0, 0x10, 0x02, 0x02, 0x00, 0x04, 0x01, 0xc0, 0x18,
  0x02, 0x02, 0x00, 0x0c, 0x00, 0x80, 0x08, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 0x08, 0x02, 0x02,
  0x00, 0x06, 0x00, 0x00, 0x18, 0x02, 0x02, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x02, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x02, 0x02, 0x00, 0x00, 0x05, 0x90, 0x00, 0x02,
  0xfa, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x02, 0xfa, 0x00, 0x00, 0x67, 0xf3, 0x00, 0x02, 0xfa, 0x00,
  0x00, 0x63, 0xe3, 0x00, 0x02, 0xfa, 0x00, 0x03, 0x61, 0xc3, 0x60, 0x02, 0xfa, 0x00, 0x03, 0xf1,
  0x87, 0xe0, 0x02, 0xfa, 0x00, 0x01, 0xf1, 0x87, 0xc0, 0x02, 0xfa, 0x00, 0x01, 0xf9, 0x8f, 0xc0,
  0x02, 0xfa, 0x00, 0x03, 0xff, 0xff, 0xe0, 0x02, 0xfa, 0x00, 0x03, 0x0f, 0xf8, 0x60, 0x02, 0xfa,
  0x00, 0x00, 0x03, 0xe0, 0x00, 0x06, 0xf9, 0x80, 0x00, 0x07, 0xf0, 0x00, 0x09, 0xfc, 0x80, 0x03,
  0xdf, 0xfd, 0xe0, 0x1b, 0xfe, 0x40, 0x03, 0xfd, 0x9f, 0xe0, 0x17, 0xff, 0x40, 0x00, 0xf1, 0x87,
  0x80, 0x3f, 0xff, 0xa0, 0x03, 0xf1, 0x87, 0xe0, 0x2f, 0xff, 0xa0, 0x03, 0xe1, 0xc7, 0xe0, 0x2f,
  0xff, 0xa0, 0x00, 0x63, 0xe3, 0x00, 0x2f, 0xff, 0xa0, 0x00, 0x67, 0xf3, 0x00, 0x2f, 0xff, 0xa0,
  0x00, 0x07, 0xf0, 0x00, 0x17, 0xff, 0x60, 0x00, 0x0d, 0xd8, 0x00, 0x17, 0xff, 0x40, 0x00, 0x01,
  0x80, 0x00, 0x0b, 0xfe, 0xc0, 0x00, 0x00, 0x80, 0x00, 0x0c, 0xf9, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
};
const uint16_t lixeira[] PROGMEM = {
  0x0000, 0x1800, 0x8000, 0xd800, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf000, 0xd800, 0x8000, 0x1800, 0x0000, 0x1000, 0xd000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xd000, 0x1000, 0x7800, 0xf000, 0xf8a2, 0xf924, 0xf924, 0xf924, 0xf924, 0xf841, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf924, 0xf924, 0xf924, 0xf924, 0xf8c3, 0xf000, 0x7800, 0xd800, 0xf800, 0xfa08, 0xffdf, 0xffff,
  0xffff, 0xffff, 0xfc51, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfb0c, 0xffff, 0xffff, 0xffff,
  0xffff, 0xfb4d, 0xf800, 0xd000, 0xf000, 0xf800, 0xf800, 0xfaaa, 0xffbe, 0xffff, 0xffff, 0xffbe, 0xfb2c, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf986, 0xff5d, 0xffff, 0xffff, 0xffff, 0xfc30, 0xf820, 0xf800, 0xf000, 0xf800, 0xf800, 0xf800,
  0xf800, 0xfc71, 0xffff, 0xffff, 0xffff, 0xffbe, 0xf9c7, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf8e3, 0xff3c, 0xffff, 0xffff,
  0xffff, 0xfdb6, 0xf841, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xfd34, 0xffff, 0xffff, 0xffff, 0xff3c,
  0xf882, 0xf800, 0xf800, 0xf800, 0xf800, 0xfdf7, 0xffff, 0xffff, 0xffff, 0xfeba, 0xf861, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf8c3, 0xfeba, 0xffff, 0xffff, 0xffff, 0xfdf7, 0xf841, 0xf800, 0xf820, 0xfcb2, 0xffff, 0xffff,
  0xffff, 0xff7d, 0xf965, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf882, 0xff5d,
  0xffff, 0xffff, 0xffff, 0xfc71, 0xf800, 0xfa8a, 0xffff, 0xffff, 0xffff, 0xffdf, 0xfa08, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfa49, 0xffff, 0xffff, 0xffff, 0xffff, 0xfcd3, 0xffbe, 0xffff,
  0xffff, 0xffff, 0xfbae, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xfb6d, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xfd14, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfd14, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xfe38, 0xf841, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf924, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xfaaa, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xfdd7, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xfeba, 0xf882, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfcb2, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xfe18, 0xf861,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfb4d, 0xffff,
  0xffff, 0xffff, 0xff9e, 0xfa8a, 0xfefb, 0xffff, 0xffff, 0xffff, 0xfc92, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf9a6, 0xffbe, 0xffff, 0xffff, 0xffdf, 0xfa08, 0xf800, 0xf904, 0xff7d, 0xffff,
  0xffff, 0xffdf, 0xfbae, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf945, 0xff5d,
  0xffff, 0xffff, 0xffff, 0xfc10, 0xf800, 0xf800, 0xf800, 0xfacb, 0xffdf, 0xffff, 0xffff, 0xffbe, 0xfa49, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf861, 0xfeba, 0xffff, 0xffff, 0xffff, 0xfd55, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xfb8e, 0xffff, 0xffff, 0xffff, 0xffbe, 0xf924, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xfd96,
  0xffff, 0xffff, 0xffff, 0xfedb, 0xf8a2, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf841, 0xfd96, 0xffff, 0xffff, 0xffff, 0xfe9a,
  0xf861, 0xf800, 0xf800, 0xf800, 0xf000, 0xf800, 0xf820, 0xfc10, 0xffff, 0xffff, 0xffff, 0xff1c, 0xf8e3, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xfe59, 0xffff, 0xffff, 0xffff, 0xfdd7, 0xf861, 0xf800, 0xf000, 0xd800, 0xf800, 0xfb4d,
  0xffff, 0xffff, 0xffff, 0xffff, 0xfa8a, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf945, 0xffff,
  0xffff, 0xffff, 0xffff, 0xfc92, 0xf800, 0xd800, 0x7800, 0xf000, 0xf986, 0xfa08, 0xfa08, 0xfa08, 0xf9e7, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf965, 0xfa08, 0xfa08, 0xfa08, 0xf9e7, 0xf000, 0x7800, 0x1000,
  0xd800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xd000, 0x1000, 0x0000, 0x1800, 0x8000, 0xd800, 0xf000, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000, 0xd800, 0x8000, 0x1800,
  0x0000
};

const unsigned char editor[] PROGMEM = {
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x78, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0e, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00,
  0x06, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x03, 0xff, 0x00, 0x00, 0x06, 0xc0,
  0x07, 0x03, 0xff, 0x03, 0xc0, 0x06, 0xc0, 0x0f, 0x87, 0xff, 0xc7, 0xe0, 0x06, 0xc0, 0x1f, 0xff,
  0xff, 0xff, 0xf0, 0x06, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xf8, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff,
  0xfc, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06,
  0xc0, 0x3f, 0xff, 0xff, 0xff, 0xf8, 0x06, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xf0, 0x06, 0xc0, 0x1f,
  0xff, 0xc7, 0xff, 0xe0, 0x06, 0xc0, 0x1f, 0xfe, 0x01, 0xff, 0xf0, 0x06, 0xc0, 0x1f, 0xfc, 0x00,
  0x7f, 0xf0, 0x06, 0xc0, 0x3f, 0xf8, 0x00, 0x3f, 0xf0, 0x06, 0xc0, 0xff, 0xf0, 0x00, 0x1f, 0xfe,
  0x06, 0xc7, 0xff, 0xe0, 0x00, 0x1f, 0xff, 0xc6, 0xc7, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0xc6, 0xc7,
  0xff, 0xe0, 0x00, 0x0f, 0xff, 0xc6, 0xc7, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xc6, 0xc7, 0xff, 0xc0,
  0x00, 0x0f, 0xff, 0xc6, 0xc7, 0xff, 0xc0, 0x00, 0x0f, 0xff, 0xc6, 0xc7, 0xff, 0xe0, 0x00, 0x0f,
  0xff, 0xc6, 0xc7, 0xff, 0xe0, 0x00, 0x0f, 0xff, 0xc6, 0xc7, 0xff, 0xf0, 0x00, 0x1f, 0xff, 0xc6,
  0xc0, 0x3f, 0xf0, 0x00, 0x3f, 0xf8, 0x06, 0xc0, 0x3f, 0xf8, 0x00, 0x3f, 0xf0, 0x06, 0xc0, 0x1f,
  0xfc, 0x00, 0xff, 0xf0, 0x06, 0xc0, 0x1f, 0xff, 0x01, 0xff, 0xe0, 0x06, 0xc0, 0x1f, 0xff, 0xff,
  0xff, 0xf0, 0x06, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xf0, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xf8,
  0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0,
  0x7f, 0xff, 0xff, 0xff, 0xf8, 0x06, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xf0, 0x06, 0xc0, 0x1f, 0xdf,
  0xff, 0xef, 0xe0, 0x06, 0xc0, 0x0f, 0x83, 0xff, 0x83, 0xc0, 0x06, 0xc0, 0x07, 0x03, 0xff, 0x01,
  0x80, 0x06, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06,
  0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x01, 0xff, 0x00, 0x00, 0x06, 0xe0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1c, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf0
};

const unsigned char casa[] PROGMEM = {
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x78, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0e, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x7c, 0x00, 0x00,
  0x06, 0xc0, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x01, 0xff, 0x80, 0x00, 0x06, 0xc0,
  0x00, 0x07, 0xff, 0xc0, 0x00, 0x06, 0xc0, 0x00, 0x0f, 0xff, 0xe0, 0x00, 0x06, 0xc0, 0x00, 0x1f,
  0xff, 0xf0, 0x00, 0x06, 0xc0, 0x00, 0x3f, 0xc7, 0xf8, 0x00, 0x06, 0xc0, 0x00, 0x7f, 0x83, 0xfc,
  0x00, 0x06, 0xc0, 0x00, 0xff, 0x01, 0xfe, 0x00, 0x06, 0xc0, 0x01, 0xfe, 0x38, 0xff, 0x00, 0x06,
  0xc0, 0x07, 0xfc, 0x7c, 0x3f, 0xc0, 0x06, 0xc0, 0x0f, 0xf0, 0xfe, 0x1f, 0xe0, 0x06, 0xc0, 0x1f,
  0xe1, 0xff, 0x0f, 0xf0, 0x06, 0xc0, 0x3f, 0xc7, 0xff, 0xc7, 0xf8, 0x06, 0xc0, 0x7f, 0x8f, 0xff,
  0xe3, 0xfc, 0x06, 0xc0, 0xff, 0x1f, 0xff, 0xf1, 0xfe, 0x06, 0xc1, 0xfe, 0x3f, 0xff, 0xf8, 0x7f,
  0x06, 0xc7, 0xfc, 0x7f, 0xff, 0xfc, 0x7f, 0xc6, 0xcf, 0xf8, 0xff, 0xff, 0xfe, 0x1f, 0xe6, 0xcf,
  0xe1, 0xff, 0xff, 0xff, 0x0f, 0xe6, 0xcf, 0xc7, 0xff, 0xff, 0xff, 0xc7, 0xe6, 0xcf, 0x8f, 0xff,
  0xff, 0xff, 0xe3, 0xe6, 0xc7, 0x1f, 0xff, 0xff, 0xff, 0xf1, 0xc6, 0xc0, 0x3f, 0xff, 0xff, 0xff,
  0xf8, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06,
  0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f,
  0xff, 0xff, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xff, 0x83, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00,
  0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc,
  0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0,
  0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe,
  0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff,
  0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06,
  0xc0, 0x7f, 0xfe, 0x00, 0xff, 0xfc, 0x06, 0xc0, 0x3f, 0xfe, 0x00, 0x7f, 0xf8, 0x06, 0xe0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1c, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf0
};
const unsigned char alarmesfuturos[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xc0, 0x01, 0x00, 0x7f, 0x00, 0x40, 0x00, 0x3f,
  0xe1, 0xf8, 0x00, 0xff, 0x8e, 0x0e, 0x3f, 0xf3, 0x83, 0x87, 0xf0, 0x0f, 0xe0, 0x1f, 0x80, 0x00,
  0x03, 0x01, 0xe0, 0x01, 0x80, 0xff, 0xc0, 0xc0, 0x60, 0x7f, 0xe3, 0xfe, 0x00, 0xff, 0xce, 0x0e,
  0x7f, 0xf3, 0x83, 0x8f, 0xfc, 0x1f, 0xf0, 0x7f, 0xc0, 0x00, 0x07, 0x01, 0xe0, 0x03, 0x80, 0xff,
  0xc0, 0xe0, 0x70, 0x7f, 0xe3, 0xfe, 0x00, 0xff, 0x8e, 0x0e, 0x7f, 0xf3, 0x83, 0x8f, 0xfc, 0x3f,
  0xf8, 0x7f, 0xc0, 0x00, 0x07, 0x81, 0xe0, 0x03, 0xc0, 0xf1, 0xe0, 0xe0, 0xf0, 0x78, 0x07, 0x8c,
  0x00, 0xe0, 0x0e, 0x0e, 0x07, 0x83, 0x83, 0x8f, 0x1e, 0x7c, 0x7c, 0xf1, 0x80, 0x00, 0x07, 0x81,
  0xe0, 0x07, 0xc0, 0xf0, 0xe1, 0xf0, 0xf0, 0x78, 0x07, 0x80, 0x00, 0xe0, 0x0e, 0x0e, 0x07, 0x03,
  0x83, 0x8e, 0x1e, 0x78, 0x3c, 0xf0, 0x03, 0x00, 0x0f, 0xc1, 0xe0, 0x07, 0xe0, 0xf1, 0xe1, 0xf1,
  0xf8, 0x78, 0x07, 0xe0, 0x00, 0xe0, 0x0e, 0x0e, 0x07, 0x03, 0x83, 0x8e, 0x1e, 0x70, 0x1e, 0x7c,
  0x07, 0x00, 0x0f, 0xc1, 0xe0, 0x0f, 0xe0, 0xff, 0xc1, 0xf9, 0xf8, 0x7f, 0xc3, 0xfc, 0x00, 0xff,
  0x0e, 0x0e, 0x07, 0x03, 0x83, 0x8f, 0xfc, 0x70, 0x1e, 0x7f, 0x87, 0x00, 0x1d, 0xe1, 0xe0, 0x0e,
  0xf0, 0xff, 0xc3, 0xfb, 0xf8, 0x7f, 0xc1, 0xfe, 0x00, 0xff, 0x0e, 0x0e, 0x07, 0x03, 0x83, 0x8f,
  0xfc, 0x70, 0x1e, 0x3f, 0xc3, 0x00, 0x1f, 0xe1, 0xe0, 0x1f, 0xf0, 0xff, 0x83, 0x9f, 0xbc, 0x7f,
  0x80, 0x3e, 0x00, 0xff, 0x0e, 0x0e, 0x07, 0x03, 0x83, 0x8f, 0xf8, 0x70, 0x1e, 0x07, 0xe0, 0x00,
  0x3f, 0xf1, 0xe0, 0x1f, 0xf0, 0xff, 0x83, 0x9f, 0x9c, 0x78, 0x00, 0x0f, 0x00, 0xe0, 0x0e, 0x0e,
  0x07, 0x03, 0x83, 0x8f, 0xf8, 0x78, 0x3c, 0x01, 0xe0, 0x00, 0x3f, 0xf1, 0xe0, 0x3f, 0xf8, 0xf3,
  0x87, 0x0f, 0x1c, 0x78, 0x03, 0x0f, 0x00, 0xe0, 0x0f, 0x1e, 0x07, 0x03, 0xc7, 0x8e, 0x78, 0x7c,
  0x3c, 0x21, 0xe2, 0x00, 0x78, 0x79, 0xfe, 0x3c, 0x38, 0xf3, 0x87, 0x0f, 0x1e, 0x7f, 0xe7, 0xfe,
  0x00, 0xe0, 0x07, 0xfe, 0x07, 0x01, 0xff, 0x0e, 0x3c, 0x3f, 0xf8, 0x7f, 0xc7, 0x00, 0x70, 0x79,
  0xff, 0x78, 0x3c, 0xf1, 0xc7, 0x0e, 0x0e, 0x7f, 0xe7, 0xfe, 0x00, 0xe0, 0x07, 0xfc, 0x07, 0x01,
  0xff, 0x0e, 0x3c, 0x1f, 0xf0, 0x7f, 0xc7, 0x80, 0x70, 0x38, 0xfe, 0x38, 0x1c, 0x61, 0xce, 0x04,
  0x0e, 0x3f, 0xe3, 0xf8, 0x00, 0xe0, 0x01, 0xf8, 0x07, 0x00, 0x7e, 0x06, 0x1c, 0x0f, 0xe0, 0x7f,
  0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char Synapse[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0f, 0x8e, 0x07, 0x30, 0x38, 0x02, 0x00, 0xfe, 0x03, 0xe0, 0xff, 0x00, 0x3f, 0xcf, 0x0f, 0x38,
  0x38, 0x07, 0x01, 0xff, 0x87, 0xf9, 0xff, 0x80, 0x3f, 0xcf, 0x1e, 0x38, 0x38, 0x07, 0x01, 0xff,
  0x8f, 0xf1, 0xff, 0x80, 0x38, 0x87, 0x9e, 0x3c, 0x38, 0x0f, 0x81, 0xe3, 0xce, 0x31, 0xe0, 0x00,
  0x38, 0x03, 0xfc, 0x3e, 0x38, 0x0f, 0x81, 0xe1, 0xce, 0x01, 0xe0, 0x00, 0x3e, 0x03, 0xf8, 0x3f,
  0x38, 0x1f, 0xc1, 0xe1, 0xcf, 0x81, 0xfe, 0x00, 0x3f, 0x81, 0xf8, 0x3f, 0xb8, 0x1d, 0xc1, 0xe3,
  0xc7, 0xe1, 0xff, 0x00, 0x1f, 0xc0, 0xf0, 0x3f, 0xf8, 0x3d, 0xe1, 0xff, 0x83, 0xf1, 0xff, 0x00,
  0x07, 0xc0, 0xf0, 0x3b, 0xf8, 0x39, 0xe1, 0xff, 0x80, 0xf9, 0xfe, 0x00, 0x01, 0xe0, 0xf0, 0x39,
  0xf8, 0x7f, 0xf1, 0xfe, 0x00, 0x79, 0xe0, 0x00, 0x01, 0xe0, 0xf0, 0x38, 0xf8, 0x7f, 0xf1, 0xe0,
  0x00, 0x39, 0xe0, 0x00, 0x3f, 0xc0, 0xf0, 0x38, 0x78, 0xff, 0xf1, 0xe0, 0x0f, 0xf9, 0xff, 0x00,
  0x3f, 0xc0, 0xf0, 0x38, 0x38, 0xf0, 0x79, 0xe0, 0x0f, 0xf9, 0xff, 0x80, 0x1f, 0x80, 0xf0, 0x38,
  0x19, 0xe0, 0x39, 0xe0, 0x07, 0xf1, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const uint16_t logo[] PROGMEM = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8400, 0x8568, 0x75a6, 0x6d86, 0x74a8, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x56a5, 0x8603, 0x8604, 0x7de3, 0x75e4, 0x6da4, 0x6d26, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8dc4,
  0x9604, 0x8e23, 0x8603, 0x75e3, 0x6dc4, 0x6585, 0x64e3, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xbde0, 0xa623, 0x9e23, 0x9602, 0x8603, 0x7de3,
  0x6dc4, 0x6585, 0x6524, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x34d3,
  0x2d52, 0x2592, 0x2590, 0x2d0e, 0x246d, 0x4410, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x9cc0, 0x95c3, 0x9623, 0x9603, 0x85e3, 0x75c3, 0x65a4, 0x6565, 0x5d06, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x5555, 0x2592, 0x1df3, 0x1e13, 0x1df2, 0x258e,
  0x2d0d, 0x3ccd, 0x0410, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x8400, 0x9de3, 0x9603, 0x8de2, 0x7dc3, 0x75a3, 0x6564, 0x5d26, 0x5467, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2533, 0x1dd3, 0x1df3, 0x1df3, 0x1df2, 0x258f, 0x2d2d, 0x34ec, 0x44cc, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x8d64,
  0x8da3, 0x7da3, 0x7584, 0x6d64, 0x54c8, 0x2bce, 0x1b13, 0x13b1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x2553, 0x25d3, 0x1df3, 0x1df2, 0x1df2, 0x254e, 0x352c, 0x3cec, 0x44ac, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7465, 0x3b2b, 0x32cc, 0x3b49,
  0x2b8d, 0x1375, 0x13d8, 0x0c17, 0x13d6, 0x0410, 0x0000, 0x0410, 0x001f, 0x0000, 0x0000, 0x07ff, 0x1517, 0x24d7, 0x1d57, 0x1db4,
  0x1df3, 0x1df2, 0x25b1, 0x2d0d, 0x2d0d, 0x350c, 0x354a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00f5, 0x11d5, 0x11f4, 0x1192, 0x2310, 0x1355, 0x0c37, 0x0c9a,
  0x0cda, 0x2476, 0x2451, 0x14d8, 0x14d8, 0x1cf6, 0x1c94, 0x14f7, 0x1519, 0x0d39, 0x0d59, 0x1596, 0x1db3, 0x1dd2, 0x250e, 0x250d,
  0x2d4c, 0x2569, 0x07e0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0a33, 0x12f7, 0x1af7, 0x1295, 0x0000, 0x0000, 0x1455, 0x1458, 0x0cda, 0x0cfa, 0x151a, 0x153a,
  0x151a, 0x151a, 0x1519, 0x1519, 0x151a, 0x1518, 0x1cb5, 0x2492, 0x2cf1, 0x24d0, 0x248d, 0x2cad, 0x2c6c, 0x0400, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffe0, 0x65c6, 0x74e8, 0x52a0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1c78,
  0x13b5, 0x13f8, 0x13f8, 0x0bd8, 0x0000, 0x0000, 0x0000, 0x0410, 0x0c15, 0x14da, 0x151a, 0x151a, 0x151b, 0x14fa, 0x14d8, 0x14b6,
  0x0c39, 0x07ff, 0x0000, 0x0000, 0x0930, 0x1152, 0x1151, 0x1169, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x84e8, 0x9dc5, 0x8604, 0x85a5, 0x7d64, 0x5b84, 0x0000, 0x0000, 0x055a, 0x1417, 0x1c78, 0x14b9, 0x149a, 0x1479, 0x13d8,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1d39, 0x14fa, 0x151a, 0x151a, 0x14d8, 0x14b5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x10f1, 0x1134, 0x10f1, 0x0010, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0417, 0x1c75, 0x1c35, 0x2414, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x9dc6, 0xa604, 0x9603,
  0x85e3, 0x7da4, 0x6d24, 0x6da4, 0x04fb, 0x1499, 0x0c79, 0x1499, 0x14b9, 0x1c99, 0x1c99, 0x1458, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x14b6, 0x1cd9, 0x1cd8, 0x2475, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x086e, 0x1113, 0x1133, 0x108e, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0478, 0x0c98, 0x14d9, 0x14b9, 0x1479, 0x1bd6, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa604, 0xa623, 0x9e03, 0x8de3, 0x7da4, 0x7565, 0x6ca5,
  0x1c57, 0x14ba, 0x0cba, 0x14ba, 0x14b9, 0x1c56, 0x1cba, 0x14b9, 0x0c15, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2394, 0x1cb9,
  0x1c98, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x10b0, 0x0912, 0x1132, 0x000c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0c97, 0x14fa, 0x0cfa, 0x14da, 0x149a, 0x13d8, 0x1332, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa5e4, 0xa603, 0x9e22, 0x85c4, 0x7585, 0x6d65, 0x6446, 0x1c15, 0x14da, 0x14fa, 0x14da,
  0x14d9, 0x0410, 0x1c77, 0x14da, 0x1479, 0x0496, 0x0000, 0x0000, 0x0000, 0x0000, 0x1c37, 0x1c79, 0x1c37, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0873, 0x08b1, 0x08f1, 0x0932, 0x10f0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x04d3, 0x14d9, 0x14fa, 0x14fa, 0x14da,
  0x147a, 0x1378, 0x12f5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0xa5c3, 0x9e03, 0x8de4, 0x7586, 0x7566, 0x7508, 0x0000, 0x0410, 0x1cb9, 0x14d9, 0x1cd9, 0x3496, 0x0000, 0x041b, 0x1499,
  0x14ba, 0x1c57, 0x0000, 0x0000, 0x0000, 0x0000, 0x13f7, 0x1439, 0x1c17, 0x0000, 0x0000, 0x0000, 0x001f, 0x10f2, 0x1133, 0x0933,
  0x1154, 0x1131, 0x0193, 0x0000, 0x0000, 0x07ff, 0x1c78, 0x1496, 0x14fa, 0x14fa, 0x14da, 0x1479, 0x1397, 0x1357, 0x1315, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6e25, 0x6509,
  0x4c8d, 0x3bae, 0x0410, 0x0000, 0x0000, 0x0000, 0x1456, 0x24f9, 0x24d8, 0x2492, 0x0000, 0x1c15, 0x14ba, 0x1c99, 0x1c56, 0x0000,
  0x0000, 0x0000, 0x13d8, 0x13d8, 0x1b96, 0x0000, 0x0000, 0x0000, 0x000d, 0x10f2, 0x1154, 0x1194, 0x11d5, 0x1215, 0x12b6, 0x1b14,
  0x13d6, 0x1436, 0x1478, 0x14b9, 0x14fa, 0x14d9, 0x1c58, 0x1bd7, 0x1377, 0x1377, 0x1316, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1b53, 0x1b98, 0x1397, 0x0395, 0x0000,
  0x0000, 0x0000, 0x1cd7, 0x1cf9, 0x1cf9, 0x24d7, 0x0000, 0x0410, 0x1c58, 0x1c79, 0x2459, 0x0410, 0x0000, 0x0217, 0x1b17, 0x1357,
  0x1355, 0x0000, 0x0000, 0x0000, 0x08b0, 0x08f3, 0x1153, 0x11b4, 0x11d5, 0x1276, 0x1358, 0x13b6, 0x1417, 0x1478, 0x14b9, 0x14d9,
  0x14b9, 0x1458, 0x13f7, 0x1b97, 0x1b77, 0x1376, 0x1237, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0376, 0x1418, 0x0c59, 0x1436, 0x0000, 0x0000, 0x0000, 0x2496, 0x1d19,
  0x1cf9, 0x1c98, 0x13b6, 0x0000, 0x1bd6, 0x1c19, 0x23d8, 0x2b16, 0x0000, 0x18d0, 0x1256, 0x1295, 0x0293, 0x0000, 0x0000, 0x108e,
  0x08d2, 0x0913, 0x1132, 0x1152, 0x1193, 0x1335, 0x0bd8, 0x0c38, 0x1458, 0x1478, 0x1498, 0x1497, 0x1355, 0x1397, 0x1396, 0x1376,
  0x1376, 0x1353, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x1438, 0x0c79, 0x1478, 0x0410, 0x0000, 0x0000, 0x07ff, 0x1cd8, 0x1cd9, 0x1c79, 0x1c16, 0x02b5,
  0x1355, 0x1af7, 0x22b7, 0x2235, 0x30d0, 0x086f, 0x1194, 0x11b3, 0x018c, 0x0000, 0x186c, 0x08b1, 0x08d2, 0x08d1, 0x18ee, 0x12f4,
  0x13b7, 0x1418, 0x1439, 0x1479, 0x1438, 0x13b5, 0x2455, 0x0000, 0x1214, 0x12d7, 0x0ad6, 0x13b6, 0x0555, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0c18, 0x1459, 0x1459, 0x14b8, 0x0000, 0x0000, 0x0000, 0x1419, 0x13f8, 0x13b8, 0x1b77, 0x1ad4, 0x001f, 0x1173, 0x1154, 0x1112,
  0x10d0, 0x0850, 0x1112, 0x08f1, 0x0000, 0x0850, 0x08b1, 0x08b2, 0x088d, 0x1150, 0x1ad4, 0x13b7, 0x1439, 0x1479, 0x1457, 0x2417,
  0x1b77, 0x1317, 0x1294, 0x1130, 0x0994, 0x0a14, 0x11b1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0xffe0, 0xbde0, 0x5540, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x12f4, 0x1356, 0x1398, 0x1316,
  0x12b5, 0x0000, 0x0000, 0x0000, 0x1253, 0x1256, 0x1256, 0x11d3, 0x10ad, 0x086d, 0x08b0, 0x08b1, 0x10af, 0x108e, 0x08b1, 0x0890,
  0x086e, 0x08b0, 0x08b1, 0x108e, 0x1150, 0x1294, 0x1397, 0x1438, 0x1c78, 0x1c38, 0x0000, 0x1171, 0x1214, 0x0ab6, 0x0af7, 0x0a15,
  0x08f2, 0x0932, 0x0015, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xb624,
  0x9604, 0x9644, 0x7644, 0x6d85, 0x45e0, 0x0000, 0x0000, 0x0000, 0x0ad6, 0x1318, 0x1319, 0x1318, 0x12b7, 0x0193, 0x0000, 0x0000,
  0x0000, 0x08d0, 0x0933, 0x0933, 0x10d0, 0x108c, 0x0890, 0x0891, 0x0871, 0x0890, 0x0890, 0x0890, 0x0890, 0x0891, 0x088f, 0x10af,
  0x1192, 0x12d6, 0x13b7, 0x1c17, 0x1bd6, 0x0000, 0x108e, 0x08b0, 0x08d1, 0x10f0, 0x0a34, 0x0974, 0x08d2, 0x08d1, 0x0010, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x9d46, 0x9e04, 0x9604, 0x8e23, 0x7e04, 0x6de5,
  0x65c6, 0x2c05, 0x0279, 0x1297, 0x1377, 0x1b59, 0x1359, 0x1b39, 0x1b18, 0x1b36, 0x0000, 0x0000, 0x0000, 0x0000, 0x088b, 0x08b1,
  0x08b1, 0x108f, 0x0870, 0x0891, 0x0870, 0x086e, 0x0892, 0x0890, 0x0891, 0x0890, 0x086f, 0x08b0, 0x0952, 0x1233, 0x1b35, 0x2bb1,
  0x0000, 0x0012, 0x088f, 0x08b1, 0x08b0, 0x08ab, 0x000a, 0x08f1, 0x0933, 0x0913, 0x10f1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x9de5, 0x9e03, 0x9e23, 0x8e03, 0x7de4, 0x6dc6, 0x5d88, 0x2433, 0x0bd9, 0x13ba,
  0x13da, 0x1b9a, 0x1b7a, 0x1359, 0x12b6, 0x19d1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x086c, 0x0891, 0x0891, 0x0871, 0x0870,
  0x084e, 0x0027, 0x0855, 0x10d0, 0x08b0, 0x0890, 0x0890, 0x088f, 0x08f0, 0x08ee, 0x0010, 0x0000, 0x000a, 0x0870, 0x08b1, 0x08b1,
  0x10af, 0x001f, 0x0000, 0x0015, 0x1133, 0x1174, 0x1152, 0x000c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0xbde0, 0x9e04, 0x9e23, 0x9e03, 0x8de4, 0x7dc5, 0x6dc6, 0x5d69, 0x2c73, 0x1419, 0x1419, 0x1bd8, 0x1b99, 0x1318, 0x0a36,
  0x0933, 0x088c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x086e, 0x0891, 0x0871, 0x0870, 0x084f, 0x000c, 0x0000, 0x0000, 0x18ef,
  0x0890, 0x0890, 0x0890, 0x086e, 0x18cc, 0x0000, 0x0000, 0x0000, 0x088f, 0x0891, 0x08b1, 0x10b0, 0x0010, 0x0000, 0x0000, 0x0000,
  0x1154, 0x11f5, 0x11d4, 0x1970, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xad40, 0x9e03, 0x9e03,
  0x95e3, 0x7dc4, 0x75a5, 0x6da6, 0x6587, 0x3c8d, 0x1396, 0x1c39, 0x13b7, 0x2376, 0x1ab5, 0x1111, 0x08f3, 0x08d2, 0x088f, 0x086f,
  0x086f, 0x086f, 0x086e, 0x0890, 0x0891, 0x0890, 0x084c, 0x0010, 0x0000, 0x0000, 0x0000, 0x0000, 0x088e, 0x0890, 0x0890, 0x086f,
  0x086e, 0x086e, 0x088e, 0x08af, 0x08d2, 0x08d1, 0x088c, 0x001f, 0x0000, 0x0000, 0x0000, 0x0000, 0x1996, 0x1235, 0x1276, 0x1255,
  0x0af7, 0x0bf8, 0x0bf8, 0x0bd7, 0x041a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x95a4, 0x95e4, 0x85c4, 0x7dc5, 0x75a5, 0x6d86,
  0x5d08, 0x3c0d, 0x02b5, 0x0000, 0x0000, 0x0000, 0x0000, 0x000a, 0x08d2, 0x08d3, 0x0891, 0x0891, 0x0891, 0x0891, 0x0890, 0x0890,
  0x0890, 0x0890, 0x084c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x088e, 0x0890, 0x0891, 0x0890, 0x0890, 0x08b0, 0x08b1, 0x08f2,
  0x0953, 0x08d0, 0x1110, 0x0015, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0a16, 0x12b7, 0x1338, 0x0bfa, 0x0c3b, 0x0c3a, 0x0c19,
  0x1398, 0x1ab3, 0x0000, 0x0000, 0x0000, 0x0000, 0x63a4, 0x7d65, 0x7da5, 0x75a5, 0x75a5, 0x6547, 0x33b0, 0x1ad4, 0x2314, 0x02b5,
  0x0000, 0x0000, 0x0000, 0x18d0, 0x08d2, 0x08b2, 0x086f, 0x0870, 0x086f, 0x086f, 0x086f, 0x0890, 0x0890, 0x0890, 0x084c, 0x000a,
  0x0000, 0x0000, 0x0000, 0x0008, 0x088e, 0x0890, 0x0890, 0x086f, 0x088f, 0x088f, 0x08af, 0x08f0, 0x0994, 0x0994, 0x0932, 0x0931,
  0x10ef, 0x08cf, 0x08af, 0x0890, 0x0890, 0x08d1, 0x0a15, 0x0bb9, 0x0c3b, 0x0c3b, 0x0c3a, 0x13da, 0x1338, 0x1296, 0x001f, 0x0000,
  0x0000, 0x0000, 0x0000, 0x7463, 0x7d46, 0x6d86, 0x6566, 0x4ce9, 0x22f4, 0x1b77, 0x13b7, 0x0bf8, 0x0000, 0x001f, 0x0912, 0x0914,
  0x08f3, 0x088f, 0x0000, 0x0000, 0x0000, 0x0000, 0x000a, 0x088f, 0x0891, 0x0890, 0x088e, 0x086d, 0x0010, 0x0000, 0x0010, 0x084d,
  0x086f, 0x0890, 0x0890, 0x084d, 0x0000, 0x0000, 0x0000, 0x0000, 0x11af, 0x1296, 0x1235, 0x11d4, 0x0972, 0x0932, 0x08f1, 0x08d1,
  0x08d1, 0x08d2, 0x09d4, 0x0b99, 0x141a, 0x141a, 0x141a, 0x1359, 0x12d7, 0x12b7, 0x0199, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x1b33, 0x0bd8, 0x0c39, 0x0c59, 0x0c16, 0x11b3, 0x1195, 0x1175, 0x0933, 0x0193, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x086c, 0x088f, 0x0890, 0x0890, 0x086f, 0x086c, 0x084e, 0x0030, 0x086f, 0x0891, 0x0891, 0x088f, 0x0010,
  0x0000, 0x0000, 0x0000, 0x0000, 0x1b14, 0x1378, 0x12f7, 0x12b6, 0x1255, 0x11d4, 0x0952, 0x08d1, 0x08d1, 0x08b1, 0x0a14, 0x0b78,
  0x0bfa, 0x13fa, 0x1379, 0x12d7, 0x12d7, 0x12b6, 0x0217, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x02b5, 0x0bb6, 0x0c59, 0x13f8, 0x12b6, 0x1236, 0x11b5, 0x11b2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x088b, 0x0890, 0x0891, 0x0890, 0x0890, 0x0870, 0x0890, 0x0890, 0x08b1, 0x08d1, 0x08b0, 0x0010, 0x0000, 0x0000, 0x0000, 0x0000,
  0x1b36, 0x13b7, 0x13b8, 0x1378, 0x1317, 0x1234, 0x1151, 0x106d, 0x0009, 0x001f, 0x0ad3, 0x1397, 0x0bd9, 0x1379, 0x12b7, 0x12b7,
  0x1ab6, 0x2273, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0210, 0x1b95,
  0x1398, 0x1358, 0x12b7, 0x2195, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x086d, 0x0890, 0x0891, 0x0890, 0x0890,
  0x0891, 0x0890, 0x0890, 0x08b0, 0x08d1, 0x1133, 0x11d3, 0x09b2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4458, 0x2bd5, 0x1418,
  0x1bb7, 0x0410, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1334, 0x1336, 0x12b7, 0x1297, 0x1a76, 0x2a31, 0x3193, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0410, 0x1396, 0x13b8, 0x1398, 0x1352, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x086f, 0x0890, 0x0892, 0x0891, 0x086f, 0x088c, 0x08f0, 0x10f1, 0x088e, 0x086e, 0x08b0,
  0x08b0, 0x19d2, 0x1af6, 0x1b34, 0x2310, 0x0000, 0x0000, 0x0000, 0x0000, 0x6310, 0x3bb3, 0x0c59, 0x13f6, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0193, 0x0919, 0x10fa, 0x10b5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x001f, 0x1458, 0x1c78, 0x13f7, 0x1398, 0x0a77, 0x0000, 0x0000, 0x0000, 0x0000, 0x10b4, 0x1112,
  0x10d0, 0x10b1, 0x08b1, 0x08b1, 0x088e, 0x10ac, 0x1192, 0x11f3, 0x11b2, 0x2110, 0x10af, 0x08f1, 0x08f1, 0x1110, 0x13f6, 0x1458,
  0x1c15, 0x2317, 0x0000, 0x0000, 0x0000, 0x0000, 0x1aef, 0x0c59, 0x1416, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x1c16, 0x14b9, 0x1498, 0x13f8, 0x1376, 0x12d4, 0x0000, 0x0000, 0x0000, 0x0010, 0x11b5, 0x1194, 0x1133, 0x1113, 0x08d1, 0x088d,
  0x001f, 0x1a74, 0x12b5, 0x12f6, 0x1296, 0x001f, 0x18f1, 0x0931, 0x1173, 0x1171, 0x1c35, 0x1498, 0x1cb8, 0x1c57, 0x055f, 0x0000,
  0x0000, 0x0217, 0x0c55, 0x0c78, 0x1437, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1498, 0x14f9, 0x14ba, 0x13f7,
  0x1356, 0x1b14, 0x11d1, 0x0000, 0x0000, 0x1150, 0x1236, 0x1216, 0x11d5, 0x19d4, 0x2171, 0x0010, 0x0000, 0x1b76, 0x1377, 0x1397,
  0x1b76, 0x0000, 0x0010, 0x1193, 0x11d4, 0x19d2, 0x1970, 0x1c76, 0x1cd8, 0x1cd8, 0x1c96, 0x0000, 0x0000, 0x0c16, 0x0cb8, 0x0cb9,
  0x1478, 0x1357, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x14b8, 0x14d9, 0x14da, 0x1478, 0x1396, 0x1b15, 0x1234, 0x0000,
  0x0000, 0x0a0f, 0x12b7, 0x1a97, 0x1276, 0x1a55, 0x2a52, 0x0000, 0x07ff, 0x13d8, 0x1418, 0x13f8, 0x0bd5, 0x0000, 0x0000, 0x1254,
  0x1a55, 0x1a75, 0x1a54, 0x07ff, 0x14f8, 0x1cf9, 0x1cd8, 0x2476, 0x0000, 0x1457, 0x14d9, 0x14d9, 0x1499, 0x1c16, 0x13b2, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0cb6, 0x1cb8, 0x1cb9, 0x1499, 0x13d7, 0x12d4, 0x0000, 0x0000, 0x0000, 0x02aa, 0x12d5, 0x1338,
  0x12d7, 0x1a55, 0x018c, 0x0000, 0x3bb1, 0x1437, 0x1479, 0x1459, 0x02b5, 0x0000, 0x0000, 0x1273, 0x1316, 0x1b17, 0x1af4, 0x3333,
  0x145a, 0x1499, 0x1cf9, 0x1c97, 0x2414, 0x1c56, 0x0cd9, 0x14d9, 0x1498, 0x1437, 0x1436, 0x2413, 0x23f4, 0x1b93, 0x0417, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x13b7, 0x2392, 0x23b4, 0x1b13, 0x001f, 0x0000, 0x0000, 0x0000, 0x0000, 0x1376, 0x0bf9, 0x1398, 0x02b5, 0x0000, 0x8410,
  0xadfa, 0x1c78, 0x1c99, 0x1c77, 0x0000, 0x0000, 0x0000, 0x0000, 0x1397, 0x1b98, 0x1b35, 0x1ad2, 0x0000, 0x1496, 0x14d8, 0x14d9,
  0x1cb8, 0x1c57, 0x1495, 0x23d3, 0x2433, 0x1bd4, 0x1457, 0x14d9, 0x14d9, 0x14b9, 0x1c57, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0bd7, 0x0c39, 0x0bf8, 0x001f, 0x0000, 0x3c53, 0x5d79, 0x14b9, 0x1cb8, 0x1495,
  0x0000, 0x0000, 0x0000, 0x0000, 0x1396, 0x13f8, 0x1bf7, 0x1bb4, 0x0000, 0x1cb6, 0x14f8, 0x14f9, 0x1cb8, 0x1c36, 0x0000, 0x0000,
  0x0000, 0x0000, 0x1c77, 0x14b9, 0x14b9, 0x14b9, 0x1c98, 0x02b5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0c18, 0x0c39, 0x1417, 0x0000, 0x0000, 0x14f7, 0x14f9, 0x14f9, 0x1cd8, 0x1c75, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0256, 0x1417, 0x1458, 0x2415, 0x0010, 0x2497, 0x1cd8, 0x14f9, 0x14f9, 0x1cb7, 0x0410, 0x0000, 0x0000, 0x0000, 0x1c36, 0x1498,
  0x1c98, 0x1c77, 0x1c36, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1333, 0x0c59, 0x0c79,
  0x13d7, 0x0496, 0x1477, 0x14f9, 0x14f9, 0x14f9, 0x1cd8, 0x2476, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1416, 0x1478, 0x1c57,
  0x1335, 0x2477, 0x1cd8, 0x1cf9, 0x1cf8, 0x1cb6, 0x0000, 0x0000, 0x0000, 0x0000, 0x021f, 0x1c15, 0x1c77, 0x2436, 0x2410, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x13d4, 0x0c79, 0x0c99, 0x1435, 0x14b7, 0x14d9, 0x14f9,
  0x1cf8, 0x1cf8, 0x14b8, 0x1c56, 0x2393, 0x0000, 0x0000, 0x0000, 0x0000, 0x13f3, 0x1498, 0x1478, 0x1d7a, 0x34d3, 0x1c77, 0x1c97,
  0x1c96, 0x2474, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0333, 0x001f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x1cf3, 0x1d75, 0x1596, 0x1577, 0x14b6, 0x1476, 0x14d8, 0x14d8, 0x1c96, 0x1d39, 0x24d7, 0x1c77, 0x1498,
  0x1477, 0x1c13, 0x0000, 0x0000, 0x0000, 0x13f4, 0x1498, 0x1498, 0x0cb4, 0x0000, 0x0410, 0x2c15, 0x34d9, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1596, 0x15d6,
  0x15f6, 0x15f6, 0x15f6, 0x1555, 0x14d6, 0x1cb7, 0x1c95, 0x0410, 0x0000, 0x0000, 0x1c12, 0x1497, 0x14b8, 0x1496, 0x14d7, 0x0000,
  0x0000, 0x1435, 0x1498, 0x1477, 0x0555, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0410, 0x1dd6, 0x1df7, 0x15f6, 0x15f6, 0x15f6, 0x1594,
  0x1d32, 0x24f3, 0x07ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x1434, 0x14b8, 0x14f8, 0x14b7, 0x1c94, 0x2cee, 0x24f0, 0x1cd4, 0x1c72,
  0x4408, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x05b6, 0x1dd7, 0x15d7, 0x15f6, 0x15f6, 0x15d5, 0x1d73, 0x1d31, 0x2510, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x1453, 0x14d7, 0x14f8, 0x1d14, 0x2d8e, 0x358c, 0x354b, 0x34e9, 0x3cc7, 0x2304, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x05f7, 0x15b6, 0x15d6, 0x15d6, 0x15d6, 0x1db4, 0x1d51, 0x2510, 0x2caf, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x1c13, 0x1cd6, 0x25b1, 0x2dcd, 0x2dcc, 0x356a, 0x3d08, 0x3ce7, 0x3c67, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x15b7, 0x1d97,
  0x15b6, 0x1d95, 0x1d52, 0x2530, 0x2cd0, 0x2c0d, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2d2d, 0x2dcd,
  0x35cc, 0x35cb, 0x3569, 0x3d07, 0x3d07, 0x44e7, 0x05e0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x055f, 0x2536, 0x2534, 0x2512, 0x24d0, 0x2c8f,
  0x2bce, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2dcb, 0x35ab, 0x3daa, 0x35aa, 0x3d48, 0x3d07,
  0x44e7, 0x44e7, 0x4408, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0410, 0x1e69, 0x0540, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4d29, 0x4588, 0x4588, 0x4547, 0x4d06, 0x44e7, 0x44e7, 0x44a8, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x5540, 0x4526, 0x4d27, 0x4d06, 0x4ce5, 0x44c6, 0x44c7, 0x1442, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x45e0,
  0x44e7, 0x4ca7, 0x4cc6, 0x4486, 0x45e8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
const uint16_t logofundobranco[] PROGMEM = {
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef9c, 0xd737, 0xcf37, 0xf7bd, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xdf77, 0xa68a, 0x8e26, 0x8607, 0x964c, 0xd759, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefbb,
  0xa669, 0x8e23, 0x8603, 0x75e3, 0x6de5, 0x8e2c, 0xf7bd, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xdf56, 0x9e23, 0x9602, 0x8603, 0x7de3,
  0x6dc4, 0x75c8, 0xd738, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xd77d, 0x8698, 0x6634, 0x8e56, 0xd75c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xdf35, 0x9623, 0x9603, 0x85e3, 0x75c3, 0x65a4, 0x75c8, 0xcf17, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xbf3b, 0x4635, 0x1e13, 0x1df2, 0x258e,
  0x4d90, 0xcf3a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xef99, 0xa647, 0x8de3, 0x85c3, 0x75a3, 0x6565, 0x7dca, 0xe77c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefbe, 0x6e97, 0x2613, 0x1e13, 0x1df2, 0x258f, 0x2d2d, 0x8e55, 0xf7be, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffde,
  0xc6d2, 0x8de6, 0x7584, 0x6d65, 0x54e8, 0x5490, 0xbe7c, 0xf7df, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xd77d, 0x5656, 0x1df3, 0x1df2, 0x1df2, 0x256e, 0x352c, 0x7e13, 0xef9d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7bd, 0x8513, 0x3aed, 0x84f1,
  0x9df6, 0x2bf6, 0x3479, 0x75ba, 0xd73e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7df, 0xcf3d, 0x7e7a, 0x35f5,
  0x1df3, 0x1df2, 0x1db1, 0x2d2d, 0x2d0d, 0x8e54, 0xefde, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0x7c99, 0x1a14, 0xadbb, 0xf7df, 0xcefd, 0x657a, 0x1cba,
  0x353a, 0x8e3b, 0xcf3c, 0x65fb, 0x763b, 0xd77e, 0xcf5d, 0x7e5b, 0x45ba, 0x257a, 0x1d79, 0x1d96, 0x25d3, 0x1dd2, 0x252e, 0x2d0d,
  0x4daf, 0xc759, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xef7e, 0x649a, 0x1b17, 0xd6fd, 0xffff, 0xffff, 0xf7df, 0x965c, 0x2d3a, 0x14fa, 0x151a, 0x151a,
  0x151a, 0x1d3a, 0x1d3a, 0x1d5a, 0x255a, 0x5dfa, 0xaebc, 0xd73d, 0x9678, 0x3511, 0x2c8d, 0x5550, 0xc71a, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xfffe, 0xffde, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xc6fd, 0x44b9, 0x3479, 0xe79f, 0xffff, 0xffff, 0xffff, 0xffff, 0xcf3d, 0x5ddb, 0x151b, 0x151a, 0x151b, 0x2d5a, 0x761b, 0xbf1d,
  0xefbf, 0xffff, 0xffff, 0xffff, 0xe73e, 0x2a33, 0x2a12, 0xd6db, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xef9a, 0xc712, 0xbeb1, 0xd716, 0xf7bd, 0xffff, 0xffff, 0xffff, 0xdf5e, 0xb6bd, 0x4d5b, 0x1cba, 0x34fa, 0xdf5e,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe7bf, 0x55bb, 0x1d1a, 0x2d5a, 0x9ebc, 0xf7bf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xa55a, 0x2194, 0x6b96, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefbf, 0xe77e, 0xf7bf, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef7a, 0xbe8b, 0x9e04,
  0x8de3, 0x85e6, 0xbeb3, 0xffff, 0xffff, 0x9e9d, 0x4d5b, 0x351a, 0x4d9b, 0x65bb, 0x2cfa, 0x8e3c, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xb6fc, 0x1cf9, 0x6dfb, 0xefdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef5e, 0x6357, 0x1994, 0xce5c, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xaedd, 0x65fb, 0x55bb, 0x75db, 0xcf1d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xd713, 0xae45, 0x9e03, 0x8de3, 0x7da4, 0x9e2d, 0xf7bd,
  0xcf3d, 0x351a, 0x0cda, 0x14da, 0x761c, 0xdf7e, 0x5dbb, 0x2d1a, 0xcf3d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xae5b, 0x24d9,
  0x8e3c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xb5db, 0x3234, 0x4ad5, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xaebc, 0x2d3a, 0x14fa, 0x14da, 0x14ba, 0x3c7a, 0xdf3d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xd713, 0xae45, 0xa622, 0x85e4, 0x75a5, 0xa64e, 0xf7de, 0xcf1d, 0x2d1a, 0x14da, 0x1cfa,
  0x865c, 0xffff, 0xaebc, 0x24fa, 0x5d7b, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x85db, 0x2cb9, 0x9e7c, 0xffff, 0xffff, 0xffff,
  0xffff, 0xf79f, 0x8458, 0x29d3, 0x1152, 0xad7a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x3d5a, 0x14fa, 0x14fa, 0x14da,
  0x147a, 0x1378, 0x8d9a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xef9b, 0xbe8b, 0x95e4, 0x75a6, 0x85c9, 0xcef7, 0xffff, 0xffff, 0xa6bd, 0x2d1a, 0x353a, 0xc71d, 0xffff, 0xffdf, 0x4d7b,
  0x1cda, 0xa67c, 0xffff, 0xffff, 0xffff, 0xffff, 0x657a, 0x2c99, 0xb6bd, 0xffff, 0xffff, 0xffff, 0xffff, 0xce7c, 0x1973, 0x0953,
  0x1174, 0xa55a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xd75e, 0x14fa, 0x14fa, 0x14da, 0x1479, 0x13b7, 0x1357, 0x6cf9, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefbb, 0x95f0,
  0x54ae, 0x9dd6, 0xffff, 0xffff, 0xffff, 0xffff, 0xbefd, 0x2d3a, 0x967c, 0xffff, 0xffff, 0xb6dc, 0x24da, 0x4d5a, 0xe79e, 0xffff,
  0xffff, 0xffff, 0x4cda, 0x3459, 0xcefd, 0xffff, 0xffff, 0xffff, 0xffdf, 0x9d1a, 0x1174, 0x11b4, 0x11d5, 0x2ab6, 0x9ddb, 0xe77e,
  0xe79e, 0xc71d, 0x7e1b, 0x251a, 0x14da, 0x14d9, 0x1c58, 0x1bd7, 0x1377, 0x1b77, 0x9dfb, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xcefd, 0x23d8, 0x5cfa, 0xf7df, 0xffff,
  0xffff, 0xffff, 0xefdf, 0x4d9a, 0x55ba, 0xd77e, 0xffff, 0xffdf, 0x5d7a, 0x2cda, 0xa67c, 0xffff, 0xffff, 0xffff, 0x3bd8, 0x3c19,
  0xdf5e, 0xffff, 0xffff, 0xffff, 0xb5bb, 0x3214, 0x2a15, 0x4b17, 0x5bd8, 0x5c19, 0x2398, 0x653a, 0x657a, 0x2cd9, 0x1cd9, 0x3d5a,
  0x4d9b, 0x1c78, 0x13f7, 0x1b97, 0x23b7, 0x5cb9, 0xef7f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0x5d3a, 0x34da, 0xd75e, 0xffff, 0xffff, 0xffff, 0xffff, 0x969c,
  0x253a, 0x8e5c, 0xf7bf, 0xffff, 0xcefd, 0x2c59, 0x5cfa, 0xdf3e, 0xffff, 0xf7bf, 0x22b6, 0x3b97, 0xef9f, 0xffff, 0xffff, 0xb5ba,
  0x29b4, 0x29d5, 0xa55a, 0xd6bd, 0xdf1e, 0x9dfb, 0x1c18, 0x1438, 0x1c78, 0x4519, 0x863c, 0xc71d, 0xbe9c, 0x1397, 0x3c58, 0x7d9a,
  0xa63c, 0xe77e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xbedd, 0x24ba, 0x965c, 0xffff, 0xffff, 0xffff, 0xffff, 0xd77e, 0x353a, 0x34fa, 0xb6bd, 0xffff,
  0xf7df, 0x7d1a, 0x2af7, 0x9d5a, 0xf7bf, 0xe71d, 0x19b4, 0x4b36, 0xffdf, 0xffff, 0xce5b, 0x3a14, 0x1913, 0x9d1a, 0xf7bf, 0xdf3e,
  0x757a, 0x2c99, 0x1459, 0x1459, 0x2c99, 0xa63b, 0xefbf, 0xffff, 0x8d1a, 0x1b17, 0x8d7b, 0xf7df, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xefbf, 0x3d1a, 0x659b, 0xefbf, 0xffff, 0xffff, 0xffff, 0xf7df, 0x8dfc, 0x1bf8, 0x3c18, 0xd71d, 0xffff, 0xce7d, 0x29f5, 0x3a54,
  0xce5c, 0xc61c, 0x1132, 0x5b35, 0xffff, 0xd6bd, 0x4ab5, 0x10f2, 0x8c77, 0xf79f, 0xbe7c, 0x4cb9, 0x1c59, 0x1479, 0x5d7a, 0x9e3c,
  0x5499, 0x33b8, 0x8d5a, 0xe73e, 0x2a75, 0x2ad6, 0xcebc, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0x857a, 0x3439, 0xa63c,
  0xf7bf, 0xffff, 0xffff, 0xffff, 0xe77e, 0x6c79, 0x1a96, 0x4316, 0xef7e, 0xef9e, 0x73d7, 0x10b2, 0x52d4, 0x5af3, 0x08d1, 0x4233,
  0xb5ba, 0x52d5, 0x10f2, 0x7bf6, 0xef7e, 0x957a, 0x23d7, 0x1c59, 0x3cf9, 0xb6bd, 0xffff, 0xef7e, 0x6c79, 0x12d6, 0x1317, 0x1a75,
  0x0913, 0x5336, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xfffe,
  0xefbb, 0xdf76, 0xd778, 0xefbc, 0xffff, 0xffff, 0xffff, 0xffff, 0xd71e, 0x2b99, 0x1339, 0x2359, 0x9ddc, 0xffdf, 0xffff, 0xffff,
  0xffff, 0xdedd, 0x5b77, 0x1154, 0x5b35, 0xdefd, 0x8437, 0x10b1, 0x0891, 0x0890, 0x0890, 0x0891, 0x08b1, 0x10f1, 0x6335, 0xbdfb,
  0x5335, 0x1ad6, 0x2c18, 0x7dbb, 0xdf5e, 0xffff, 0xf7bf, 0x94b8, 0x1952, 0x6395, 0x7499, 0x2a76, 0x10f2, 0x6376, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffde, 0xdf55, 0xa668, 0x8e24, 0x7e25, 0x966c,
  0xd779, 0xffff, 0xf7df, 0xdf3e, 0x859b, 0x1b79, 0x1359, 0x1b59, 0x6cfb, 0xf7bf, 0xffff, 0xffff, 0xffff, 0xffff, 0xd6bc, 0x4ab5,
  0x10d1, 0x4a73, 0x1911, 0x10b1, 0x31d3, 0x4233, 0x4235, 0x10f1, 0x08b1, 0x2172, 0x6b76, 0x29b2, 0x1173, 0x53d7, 0xb65c, 0xf7df,
  0xffff, 0xffdf, 0x9cf9, 0x2152, 0x5b15, 0xdedc, 0xffff, 0xbdfb, 0x2194, 0x3235, 0xd6bd, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef79, 0xae68, 0x9e23, 0x8e23, 0x7e04, 0x6de6, 0x860d, 0x9e39, 0x7dbc, 0x54fb,
  0x2c5a, 0x1bba, 0x1b7a, 0x1b59, 0x74da, 0xf7bf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xa518, 0x0891, 0x0891, 0x0891, 0x4254,
  0xb5ba, 0xd6bb, 0xd69e, 0x7bf7, 0x10d1, 0x08b0, 0x10b1, 0x2171, 0x8c78, 0xdefd, 0xffff, 0xffff, 0xffff, 0xa519, 0x2152, 0x4a95,
  0xce7c, 0xffff, 0xffff, 0xffff, 0x7418, 0x19d5, 0x8cb9, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xd734, 0x9e24, 0x9e03, 0x8de4, 0x7dc5, 0x6dc6, 0x6589, 0x3494, 0x1c19, 0x349a, 0x6d5b, 0x8dbc, 0x7d3b, 0x3317,
  0x2a15, 0xb5ba, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x6335, 0x0891, 0x10b1, 0x5294, 0xce5c, 0xffdf, 0xffff, 0xffff, 0xe73e,
  0x7396, 0x10d0, 0x08b0, 0xa519, 0xf7bf, 0xffff, 0xffff, 0xffff, 0xb5ba, 0x2993, 0x29b3, 0xce7c, 0xffff, 0xffff, 0xffff, 0xffff,
  0xd6dd, 0x2276, 0x4b57, 0xd6dd, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xdf34, 0x9e04,
  0x95e3, 0x85c4, 0x75a5, 0x6da6, 0x6da9, 0x9615, 0xbedd, 0xe79f, 0xf7bf, 0xf7df, 0xf7bf, 0xad7a, 0x29f5, 0x29b4, 0x73b6, 0x7396,
  0x7396, 0x73b6, 0x7bd6, 0x2131, 0x0891, 0x1931, 0xa538, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc63b, 0x39f3, 0x0890, 0x4233,
  0x6355, 0x6355, 0x6b75, 0x6355, 0x31d3, 0x1932, 0xbdfa, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7df, 0x7cba, 0x22b7, 0x9d7b,
  0xd71e, 0x8e1c, 0x7ddc, 0xb6bd, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe779, 0xa628, 0x85c4, 0x7dc5, 0x75a5, 0x6da6,
  0x758c, 0xc6da, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x8cb9, 0x1133, 0x10d2, 0x10b1, 0x10d1, 0x10d1, 0x10b1, 0x0890,
  0x0890, 0x2131, 0xad79, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xce7c, 0x39f3, 0x0891, 0x08b0, 0x10d0, 0x10d1, 0x10f1, 0x1132,
  0x1173, 0x52f5, 0xf79f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xcebe, 0x2b38, 0x2398, 0x1c3a, 0x0c5b, 0x0c3a, 0x143a,
  0x757b, 0xef9e, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7de, 0xc6d3, 0x962a, 0x85e8, 0x7de8, 0x7dcb, 0x4c31, 0x4bf7, 0xc69c, 0xffff,
  0xffff, 0xffff, 0xffff, 0xdedd, 0x5b36, 0x29d4, 0x7bf7, 0x8417, 0x8417, 0x8437, 0x7c17, 0x1931, 0x0890, 0x2131, 0xa518, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xbdfb, 0x31d2, 0x08b1, 0x5ad4, 0x8437, 0x8457, 0x8c78, 0x8478, 0x5377, 0x11d4, 0x42b5, 0xad9a,
  0xe73e, 0xef7e, 0xdefd, 0xce7c, 0xad9a, 0x8478, 0x32f6, 0x0bb9, 0x0c3a, 0x143b, 0x0c3a, 0x13fa, 0x2398, 0xae1c, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffde, 0xdf59, 0xc716, 0xc716, 0xd75a, 0xa5fb, 0x4458, 0x54d9, 0xcf3e, 0xffff, 0xffff, 0xe71e, 0x6bb8,
  0x3215, 0xa559, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x5af5, 0x08b1, 0x10d1, 0x5af4, 0xce7c, 0xffdf, 0xffff, 0xffff, 0xd6bc,
  0x5af4, 0x10d1, 0x2131, 0xce5b, 0xffff, 0xffff, 0xffff, 0xffff, 0xdefd, 0x2b17, 0x1235, 0x2234, 0x63d7, 0x7417, 0x52f5, 0x2193,
  0x10f1, 0x1952, 0x2235, 0x13b9, 0x141b, 0x141a, 0x0c1a, 0x1379, 0x1af7, 0x959b, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xf7df, 0xc6fd, 0x4d3a, 0x4d5b, 0xcf3d, 0xe73e, 0x6c19, 0x3297, 0x9d1a, 0xf7bf, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xd69c, 0x52b4, 0x08b0, 0x10d0, 0x4a93, 0xc61b, 0xdefd, 0xdedd, 0x5af4, 0x08b1, 0x1912, 0x8437, 0xf79f,
  0xffff, 0xffff, 0xffff, 0xffff, 0xe77e, 0x2bf8, 0x1317, 0x12b6, 0x1275, 0x2a75, 0x42d5, 0x6b76, 0x8c98, 0xa53a, 0x953a, 0x3419,
  0x0bfa, 0x13fa, 0x1379, 0x12d8, 0x1af7, 0x9dbc, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xbedd, 0x24b9, 0x3cba, 0x5439, 0x2ad7, 0x951b, 0xef9f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0x94b6, 0x10d1, 0x08b1, 0x10b1, 0x31b2, 0x39f3, 0x39f3, 0x10d1, 0x08b1, 0x2193, 0xb5db, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xf7df, 0x5cfa, 0x1bb8, 0x1378, 0x5459, 0xc67c, 0xdf1d, 0xef5e, 0xffdf, 0xffff, 0xef9e, 0x757b, 0x1bf9, 0x1399, 0x12d7, 0x1ab7,
  0x3b98, 0xc69c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x8dda,
  0x13b8, 0x1b78, 0x6cba, 0xef7f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x9cd8, 0x2132, 0x08b1, 0x2151, 0x1911,
  0x08b1, 0x0891, 0x08b1, 0x08b0, 0x2172, 0x29f4, 0x4b56, 0xe75e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe77e, 0x6cf8, 0x1c39,
  0x95fb, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe77e, 0x6d1a, 0x1b17, 0x1ab7, 0x3b37, 0xb61b, 0xffdf, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x6d3a, 0x13b8, 0x4cba, 0xef9e, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf79e, 0x8417, 0x10f2, 0x10f1, 0x6335, 0xad79, 0x31f2, 0x29b2, 0x7395, 0x5af4, 0x08b0,
  0x52d4, 0x9519, 0x3376, 0x74f8, 0xffdf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffdf, 0xa5fa, 0x1c99, 0x9e3c, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xdf1f, 0xd6be, 0xf79f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefbf, 0xc71d, 0x3479, 0x23f8, 0xcede, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7bf, 0xdf1e,
  0xce7c, 0x6376, 0x1112, 0x29b3, 0x9cd8, 0xf7bf, 0x9d7a, 0x1a14, 0x7c78, 0xf7bf, 0xef7e, 0x31f3, 0x3233, 0xbdfb, 0x7dba, 0x2478,
  0x961a, 0xf7df, 0xffff, 0xffff, 0xffff, 0xffff, 0x9db8, 0x1c99, 0x9e5c, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xf7bf, 0x8e5c, 0x2cf9, 0x1418, 0x23b7, 0xb65c, 0xffff, 0xffff, 0xffff, 0xffdf, 0x9d5b, 0x5357, 0x3a55, 0x1974, 0x4295, 0xb5ba,
  0xffff, 0xf7bf, 0x7cfa, 0x1b17, 0xadfc, 0xffff, 0xffdf, 0x7c17, 0x19b3, 0x9d3a, 0xdf7e, 0x559a, 0x2cf8, 0xb6bd, 0xffff, 0xffff,
  0xffff, 0xffff, 0x7e1a, 0x1cb9, 0x963b, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xd75e, 0x4d9b, 0x14ba, 0x13f7,
  0x1376, 0x5457, 0xf7bf, 0xffff, 0xffff, 0xdefd, 0x2297, 0x1236, 0x11d5, 0x4b17, 0xc65c, 0xffff, 0xffff, 0xe77e, 0x4c99, 0x3c59,
  0xcefd, 0xffff, 0xffff, 0xc65c, 0x2255, 0x63f7, 0xe73d, 0xcf3d, 0x3539, 0x457a, 0xcf3d, 0xffff, 0xffff, 0xc6fd, 0x3539, 0x14b9,
  0x65bb, 0xef9f, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xcf5e, 0x459b, 0x1cda, 0x1479, 0x13b6, 0x5478, 0xf7bf, 0xffff,
  0xffff, 0xdf1d, 0x1ad8, 0x1a97, 0x1a77, 0x6c79, 0xe75e, 0xffff, 0xffff, 0xcf1e, 0x2459, 0x759b, 0xef9f, 0xffff, 0xffff, 0xe75e,
  0x53d8, 0x3316, 0xc69d, 0xffff, 0xaefd, 0x2d39, 0x6ddb, 0xe79e, 0xffff, 0x861b, 0x14d9, 0x14d9, 0x24d9, 0x8dfa, 0xe79e, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xf7df, 0x7e1b, 0x1cd9, 0x1499, 0x2417, 0xb65c, 0xffff, 0xffff, 0xffff, 0xffff, 0x8d7a, 0x1338,
  0x2b38, 0xa5db, 0xffdf, 0xffff, 0xf7df, 0x9e5c, 0x2499, 0xa69d, 0xffff, 0xffff, 0xffff, 0xf7df, 0x8d7b, 0x1b37, 0x95ba, 0xffdf,
  0xf7df, 0x863c, 0x251a, 0x75fa, 0xa67b, 0xa69c, 0x14d9, 0x14d9, 0x1cb8, 0x2478, 0x4d19, 0xae7b, 0xa65b, 0xc6dc, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xf7bf, 0xb67b, 0x8dd9, 0xcefd, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xbebd, 0x1419, 0x6d5b, 0xf7df, 0xffff, 0xffff,
  0xef7e, 0x5d7a, 0x3d1a, 0xc71d, 0xffff, 0xffff, 0xffff, 0xffff, 0xbedd, 0x3418, 0x5458, 0xef9e, 0xffff, 0xe79e, 0x4d9a, 0x14d9,
  0x2cf9, 0xe77e, 0xd75d, 0xae7b, 0xdf5d, 0xa65b, 0x34d8, 0x14d9, 0x14d9, 0x2d1a, 0xaebc, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x961c, 0x1c59, 0x8e1c, 0xffff, 0xffff, 0xe77e, 0x9e7b, 0x24d9, 0x559a, 0xdf7e,
  0xffff, 0xffff, 0xffff, 0xffff, 0xe77e, 0x5d3a, 0x2418, 0xc6dd, 0xffff, 0xf7df, 0x865b, 0x1cf9, 0x24d9, 0x963b, 0xffff, 0xffff,
  0xffff, 0xffff, 0x8e3b, 0x1cd9, 0x14b9, 0x1cd9, 0x863b, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0x657a, 0x249a, 0xb6bd, 0xffff, 0xffff, 0xa6dc, 0x1d19, 0x14f9, 0x4d9a, 0xd75d, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffdf, 0x85fb, 0x2478, 0x7599, 0xffff, 0xe79e, 0x559a, 0x14f9, 0x14f9, 0x4558, 0xffff, 0xffff, 0xffff, 0xffff, 0xc71d, 0x4539,
  0x1c98, 0x4519, 0xb6dc, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7bf, 0x24b9, 0x34fa,
  0xdf7e, 0xffff, 0xbf1d, 0x459a, 0x14f9, 0x14f9, 0x3d59, 0xc71d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc6fd, 0x3d19, 0x34b8,
  0xf7bf, 0xefbf, 0x6dfb, 0x1cf9, 0x1cf8, 0x75fa, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc6fd, 0x965b, 0xbedd, 0xf7df, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc6fc, 0x0c99, 0x4d7a, 0xe79e, 0x967c, 0x3d5a, 0x1d19,
  0x2d39, 0x1cf8, 0x24f8, 0x85fa, 0xef9e, 0xffff, 0xffff, 0xffff, 0xffff, 0xdf7e, 0x4d5a, 0x1c98, 0xe7bf, 0xffff, 0xd75e, 0x967c,
  0x9e7c, 0xe79e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xefde, 0xa6fb, 0x4df8, 0x1577, 0x5599, 0x6dda, 0x24f9, 0x2d19, 0x9e9c, 0xe7bf, 0xd77e, 0x7dfa, 0x24d8,
  0x7e1b, 0xf7df, 0xffff, 0xffff, 0xffff, 0xdf5e, 0x455a, 0x24b8, 0xefdf, 0xffff, 0xffff, 0xf7df, 0xf7df, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xefdf, 0x6eba,
  0x1df7, 0x15f6, 0x15f6, 0x1555, 0x14d6, 0x4558, 0xbf1d, 0xffff, 0xffff, 0xffff, 0xef9e, 0x6dfa, 0x1cf9, 0x7e1a, 0xf7df, 0xffff,
  0xffff, 0xcf3d, 0x455a, 0x3d18, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xb75c, 0x2e17, 0x1df7, 0x15f6, 0x15f6, 0x1594,
  0x2d73, 0xb6fb, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe79e, 0x6dfb, 0x1d19, 0x65da, 0xdf7e, 0xf7de, 0xb6fb, 0x3d56, 0x5d77,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x9f1c, 0x1df7, 0x15f6, 0x15f6, 0x15d5, 0x1d93, 0x3572, 0xb6fa, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xe79e, 0x761b, 0x1d19, 0x4db7, 0x8675, 0x4def, 0x354b, 0x4d4c, 0xaeb6, 0xf7de, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xa71c, 0x25d7, 0x15d6, 0x15d6, 0x1db4, 0x1d51, 0x4572, 0xc71b, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xefbf, 0x7e3a, 0x25b2, 0x2dcd, 0x2dcc, 0x356a, 0x3d08, 0x4d29, 0xbeb6, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xcf9e, 0x4e18,
  0x1db6, 0x1db5, 0x1d72, 0x2551, 0x75f5, 0xef9e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xe79d, 0x35ce,
  0x35cc, 0x35cb, 0x3569, 0x3d08, 0x4508, 0x7dcf, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xc75d, 0x65f7, 0x3533, 0x4552, 0x8e37,
  0xe77d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7de, 0x45ec, 0x3daa, 0x35aa, 0x3d48, 0x3d07,
  0x4507, 0x75ae, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7fe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xf7ff, 0x762f, 0x45a9, 0x4547, 0x4d06, 0x44e7, 0x4d08, 0xae95, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xd759, 0x75ed, 0x5d49, 0x5d28, 0x654a, 0x9e32, 0xf7de, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xdf7b, 0xbed6, 0xb6b5, 0xcf19, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};
const uint16_t reset[] PROGMEM = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1800, 0x4000, 0x8800, 0xb800, 0xd800, 0xf000, 0xf000,
  0xd800, 0xb800, 0x8800, 0x4000, 0x1800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2800, 0x7800, 0xc000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf000, 0xc000, 0x7800, 0x2800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x6000, 0xd800, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf000, 0xd000, 0x5800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x8800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf861, 0xf882, 0xf882, 0xf861, 0xf820, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf000, 0x8000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000, 0x9000, 0xf000, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf8e3, 0xfacb, 0xfc30, 0xfd34, 0xfdd7, 0xfdd7, 0xfd55, 0xfc51, 0xfacb, 0xf8e3, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf000, 0x9000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x9000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xfb8e,
  0xfeba, 0xff9e, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xff9e, 0xfeba, 0xfb4d, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000,
  0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x5000, 0xf800, 0xf904, 0xf9c7, 0xf861, 0xf8e3, 0xfd75, 0xffff, 0xffff, 0xffff,
  0xff9e, 0xff1c, 0xfedb, 0xfedb, 0xff1c, 0xff9e, 0xffff, 0xffff, 0xffff, 0xfdb6, 0xf8e3, 0xf800, 0xf800, 0xf800, 0xf800, 0x5000,
  0x0000, 0x0000, 0x0000, 0x2000, 0xd000, 0xf800, 0xfc51, 0xffbe, 0xfd14, 0xfdd7, 0xffff, 0xffff, 0xff3c, 0xfcb2, 0xfaaa, 0xf945,
  0xf882, 0xf882, 0xf945, 0xfaaa, 0xfcb2, 0xff3c, 0xffff, 0xffff, 0xfdb6, 0xf8e3, 0xf800, 0xf800, 0xf800, 0xd000, 0x2000, 0x0000,
  0x0000, 0x7800, 0xf000, 0xf820, 0xfc92, 0xffff, 0xffff, 0xffff, 0xffff, 0xfefb, 0xfa08, 0xf841, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf841, 0xfa08, 0xfefb, 0xffff, 0xffff, 0xfd75, 0xf800, 0xf800, 0xf800, 0xf000, 0x7800, 0x0000, 0x1800, 0xc000,
  0xf800, 0xf841, 0xfcd3, 0xffff, 0xffff, 0xffff, 0xffff, 0xfe59, 0xf9a6, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf8e3, 0xfefb, 0xffff, 0xffff, 0xfb2c, 0xf800, 0xf800, 0xf800, 0xc000, 0x1800, 0x3800, 0xf000, 0xf800, 0xf861,
  0xfd14, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xfd96, 0xf882, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xfa08, 0xff5d, 0xffff, 0xfeba, 0xf8e3, 0xf800, 0xf800, 0xf000, 0x3800, 0x8000, 0xf800, 0xf800, 0xf861, 0xfd55, 0xffff,
  0xffff, 0xffff, 0xffff, 0xfd96, 0xf9a6, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf841,
  0xfcd3, 0xffff, 0xff9e, 0xfacb, 0xf800, 0xf800, 0xf800, 0x8000, 0xb800, 0xf800, 0xf800, 0xf882, 0xfd96, 0xffff, 0xff9e, 0xfe18,
  0xfa28, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfaaa, 0xff9e,
  0xffff, 0xfc51, 0xf820, 0xf800, 0xf800, 0xb000, 0xd800, 0xf800, 0xf800, 0xf861, 0xfcb2, 0xfd96, 0xfacb, 0xf882, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf945, 0xff1c, 0xffff, 0xfd55,
  0xf861, 0xf800, 0xf800, 0xd800, 0xf000, 0xf800, 0xf800, 0xf800, 0xf882, 0xf882, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf882, 0xfedb, 0xffff, 0xfdf7, 0xf8a2, 0xf800,
  0xf800, 0xe800, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xf8c3, 0xf820, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf882, 0xfedb, 0xffff, 0xfdf7, 0xf8a2, 0xf800, 0xf800, 0xe800,
  0xd800, 0xf800, 0xf800, 0xf800, 0xf965, 0xfc30, 0xfdf7, 0xf945, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf924, 0xff1c, 0xffff, 0xfd96, 0xf882, 0xf800, 0xf800, 0xd800, 0xb800, 0xf800,
  0xf800, 0xf800, 0xfc10, 0xffff, 0xff9e, 0xfaaa, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf800, 0xfa8a, 0xff7d, 0xffff, 0xfc92, 0xf820, 0xf800, 0xf800, 0xb800, 0x8000, 0xf800, 0xf800, 0xf800,
  0xfaeb, 0xffbe, 0xffff, 0xfcd3, 0xf841, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800,
  0xf800, 0xf841, 0xfcb2, 0xffff, 0xffbe, 0xfb0c, 0xf800, 0xf800, 0xf800, 0x8000, 0x3800, 0xf000, 0xf800, 0xf800, 0xf8e3, 0xfeba,
  0xffff, 0xff3c, 0xfa28, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xfa08,
  0xff3c, 0xffff, 0xfedb, 0xf904, 0xf800, 0xf800, 0xf000, 0x3800, 0x1800, 0xc000, 0xf800, 0xf800, 0xf800, 0xfb6d, 0xffff, 0xffff,
  0xfefb, 0xf924, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf945, 0xfefb, 0xffff, 0xffff,
  0xfb8e, 0xf800, 0xf800, 0xf800, 0xc000, 0x1800, 0x0000, 0x7800, 0xf000, 0xf800, 0xf800, 0xf800, 0xfdb6, 0xffff, 0xffff, 0xfefb,
  0xfa08, 0xf820, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf841, 0xfa28, 0xfefb, 0xffff, 0xffff, 0xfdb6, 0xf800, 0xf800,
  0xf800, 0xf000, 0x7800, 0x0000, 0x0000, 0x2000, 0xd000, 0xf800, 0xf800, 0xf800, 0xf8e3, 0xfdb6, 0xffff, 0xffff, 0xff3c, 0xfc92,
  0xfacb, 0xf965, 0xf882, 0xf8c3, 0xf986, 0xfacb, 0xfcf3, 0xff5d, 0xffff, 0xffff, 0xfdd7, 0xf904, 0xf800, 0xf800, 0xf800, 0xd000,
  0x2000, 0x0000, 0x0000, 0x0000, 0x5000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf904, 0xfdb6, 0xffff, 0xffff, 0xffff, 0xff9e, 0xff1c,
  0xfedb, 0xfefb, 0xff3c, 0xff9e, 0xffff, 0xffff, 0xffff, 0xfdb6, 0xf904, 0xf800, 0xf800, 0xf800, 0xf800, 0x5000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x9000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xfb4d, 0xfeba, 0xff9e, 0xffff, 0xffff, 0xffff, 0xffff,
  0xffff, 0xffff, 0xffbe, 0xfedb, 0xfbae, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000, 0x8800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x1000, 0x9000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf8e3, 0xfacb, 0xfc71, 0xfd75, 0xfdf7, 0xfdf7, 0xfd75, 0xfc92,
  0xfb0c, 0xf904, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000, 0x9000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x1000, 0x8000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf820, 0xf882, 0xf8a2, 0xf8a2, 0xf882, 0xf820, 0xf800, 0xf800,
  0xf800, 0xf800, 0xf800, 0xf000, 0x8000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x5800, 0xd000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000,
  0xd000, 0x5800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2800,
  0x7800, 0xc000, 0xf000, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf800, 0xf000, 0xc000, 0x7800, 0x2800, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1800,
  0x4000, 0x8800, 0xb800, 0xd800, 0xf000, 0xf000, 0xd800, 0xb800, 0x8800, 0x4000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000
};
const uint16_t lapis[] PROGMEM = {
  0xffff, 0xffff, 0xffff, 0xef5d, 0xa534, 0x5aeb, 0x10a2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x18c3, 0x5aeb, 0xad55, 0xef5d, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xbdd7, 0x4208, 0x0882, 0x01a7, 0x024b, 0x028c,
  0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac,
  0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x028c, 0x024b, 0x01a7, 0x0882, 0x4228, 0xbdd7, 0xffff, 0xffff,
  0xffff, 0xbdd7, 0x1082, 0x00e4, 0x03d1, 0x04f7, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6,
  0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6,
  0x04d6, 0x04d6, 0x04f7, 0x03d1, 0x00e4, 0x1082, 0xbdf7, 0xffff, 0xef5d, 0x39e7, 0x00e4, 0x0433, 0x04d6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x0433, 0x00e4, 0x39e7, 0xef5d,
  0xa534, 0x08a2, 0x03f2, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0187, 0x01c8, 0x0412, 0x04d6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x03f2, 0x08a2, 0xad55, 0x52aa, 0x01a7, 0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x01e9, 0x0000, 0x0000, 0x0000, 0x00e4, 0x0454, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04f7, 0x01a7, 0x5acb,
  0x18e3, 0x026b, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x024a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0104,
  0x03f2, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x024a, 0x18e3, 0x0000, 0x028c, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6,
  0x04b6, 0x032f, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00c4, 0x03f2, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x028c, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x0495, 0x0370, 0x04b6, 0x04d6, 0x032e, 0x0041, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0104, 0x0454, 0x04d6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x022a, 0x0021,
  0x024a, 0x0495, 0x04d6, 0x032e, 0x0062, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00e4, 0x0433, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x01e9, 0x0000, 0x0000, 0x0020, 0x026b, 0x04f7, 0x04b6, 0x032e, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x02ed, 0x04d6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x0495, 0x022a, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0020, 0x028c, 0x04b5, 0x04d6, 0x032e, 0x0062, 0x0000, 0x0000, 0x0000, 0x0000, 0x02ee, 0x04d6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04d6, 0x022a, 0x0021, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x024a, 0x04b5, 0x04b6, 0x032e, 0x0041,
  0x0000, 0x0000, 0x0082, 0x0433, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x01e9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0020, 0x028c, 0x04f7, 0x04d6, 0x030e, 0x0020, 0x0062, 0x03d2, 0x04d6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x0495, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x026b, 0x0495, 0x04f6,
  0x032f, 0x0370, 0x04d6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x0209, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x024a, 0x04b5, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x0495, 0x0209,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00a3, 0x0433,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x022a, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x034f, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x01e9, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x03b1, 0x04d6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x0495, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0082, 0x034f, 0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x022a, 0x0021, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x034f, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04d6, 0x01e9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0041, 0x03b1, 0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x0495, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0082, 0x034f, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6,
  0x0209, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041,
  0x0370, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x0495, 0x0209, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0082, 0x0370, 0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0020,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x034f, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x04d6, 0x0145, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x03b1, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04d6, 0x0474, 0x0082, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0082, 0x034f, 0x04f7, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04d6, 0x0370, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0041, 0x034f, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04f7, 0x022a, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x03b1, 0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x02ac, 0x04d6, 0x04b6, 0x04b6, 0x00e4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0082, 0x034f, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000, 0x0000, 0x02ac, 0x04d6, 0x04d6, 0x0413, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0041, 0x0370, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x02ac, 0x0000,
  0x0000, 0x028c, 0x04d6, 0x04d6, 0x032f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0082, 0x0370,
  0x04f7, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x028c, 0x0000, 0x18e3, 0x024a, 0x04d6, 0x04b6, 0x022a, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0082, 0x0146, 0x020a, 0x0390, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x024a, 0x18e3,
  0x52cb, 0x01a7, 0x04f7, 0x04b5, 0x0187, 0x0000, 0x0000, 0x0020, 0x00e4, 0x024a, 0x0390, 0x0474, 0x04d6, 0x04d6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04f7, 0x01a7, 0x5acb, 0xad55, 0x08a3, 0x0412, 0x04d6, 0x03f2, 0x02ac, 0x034f, 0x0433,
  0x04b6, 0x04f7, 0x04d6, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x03f2, 0x08a2, 0xad55,
  0xef5d, 0x39e7, 0x00e4, 0x0433, 0x04d6, 0x04b6, 0x04d6, 0x04d6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6, 0x04b6,
  0x04b6, 0x04b6, 0x04b6, 0x04d6, 0x0433, 0x00e4, 0x4208, 0xef5d, 0xffff, 0xbdf7, 0x1082, 0x00e4, 0x03d1, 0x04f7, 0x04d6, 0x04d6,
  0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6,
  0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04d6, 0x04f7, 0x03d1, 0x00e4, 0x1082, 0xbdf7, 0xffff,
  0xffff, 0xffff, 0xbdd7, 0x4208, 0x0882, 0x01a7, 0x024b, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac,
  0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac, 0x02ac,
  0x028c, 0x024b, 0x01a7, 0x0882, 0x4208, 0xbdd7, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xef5d, 0xa534, 0x5aeb, 0x10a2, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x18c3, 0x5aeb, 0xa534, 0xef5d, 0xffff, 0xffff, 0xffff
};

// Scroll config
int scrollOffset = 0;
const int lineHeight = 18;

bool alarmeBloqueado[6] = { false, false, false, false, false, false };

const unsigned long INTERVALO_TROCA_PARA_DATA = 30000;  // tempo entre trocas (30s)
const unsigned long DURACAO_EXIBICAO_DATA = 3000;       // quanto tempo a data fica na tela (3s)

bool rtcCalibrado = false;  // 🔒 false = descalibrado, true = calibrado
bool rtcDisponivel = false;
bool remedioTomado[6] = { false, false, false, false, false, false };
// --- Estrutura para linhas do scroll ---
struct LinhaScroll {
  String texto;
  uint16_t cor;
};
unsigned long tempoTomado[6] = {0,0,0,0,0,0};
LinhaScroll linhasScroll[18];  // 6 alarmes x 3 linhas cada
const int totalLinhas = 18;

// --- Área do scroll ---
#define SCROLL_X 255
#define SCROLL_Y 140
#define SCROLL_W 185
#define SCROLL_H 163


//Construção da lógica dos botões
struct Botao {
  int x, y, largura, altura;
  uint16_t corNormal;
  uint16_t corPressionado;
  const char* texto;
  bool pressionado;
  int indice;
  bool toggle;
  bool ativo;
};

#define NUM_BOTOES 115
Botao botoes[NUM_BOTOES];

// Enumeração de telas
enum AppScreen {
  SCREEN_HOME,
  SCREEN_EDITOR,
  SCREEN_DEFAL1,
  SCREEN_DEFAL2,
  SCREEN_DEFAL3,
  SCREEN_DEFAL4,
  SCREEN_DEFAL5,
  SCREEN_DEFAL6,
  SCREEN_RESETALL,
  SCREEN_RESET1,
  SCREEN_RESET2,
  SCREEN_RESET3,
  SCREEN_RESET4,
  SCREEN_RESET5,
  SCREEN_RESET6,
  SCREEN_KEYBOARD,
  SCREEN_ERRODEF,
  SCREEN_INFO,
  SCREEN_INFO1,
  SCREEN_INFO2,
  SCREEN_CALIBRACAO,
  SCREEN_ALARMETOCANDO
};
String comando;
int tecladoAberto = 0;                  // 0 = fechado, 1 = aberto
int lastScreen = -1;                    // tela anterior
AppScreen currentScreen = SCREEN_HOME;  // Tela inicial

uint8_t telaOrigem = 0;  // Pode armazenar SCREEN_DEFAL1 até SCREEN_DEFAL6

// --- Controle de toggles por tela DEFAL ---
const int NUM_DEFAL_SCREENS = 6;  // SCREEN_DEFAL1 até SCREEN_DEFAL6
int ultimoToggleAtivoPorTela[NUM_DEFAL_SCREENS] = { -1, -1, -1, -1, -1, -1 };
bool bloqueioTogglePorTela[NUM_DEFAL_SCREENS] = { false, false, false, false, false, false };

bool podeClicarScrollCima = true;
bool podeClicarScrollBaixo = true;

// Função auxiliar para limitar o texto do alarme a 10 caracteres + "..." se necessário
String limitarTexto(const char* texto, int limite = 10) {
  int len = strlen(texto);
  if (len <= limite) return String(texto);
  String resultado = "";
  for (int i = 0; i < limite; i++) resultado += texto[i];
  resultado += "...";
  return resultado;
}

// --- Estrutura do alarme ---
struct AlarmeRTC {
  String nome;
  byte hora;
  byte minuto;
  byte ciclo;  // 0 = sem ciclo, 6, 8, 12 = ciclos em horas
  bool ativo;
  time_t proximaExecucao;
};

AlarmeRTC alarmes[6];


// Função auxiliar: retorna número de dias no mês
int diasNoMes(int mes, int ano) {
  switch (mes) {
    case 1:
    case 3:
    case 5:
    case 7:
    case 8:
    case 10:
    case 12:
      return 31;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    case 2:
      return ((ano % 4 == 0 && ano % 100 != 0) || (ano % 400 == 0)) ? 29 : 28;
    default:
      return 30;
  }
}

// --- Controle de atualização HOME ---
unsigned long ultimoMinutoAtualizado = 0;

int horaAtualGlobal = 0;
int minutoAtualGlobal = 0;

int minutosRestantes[6] = { 99999, 99999, 99999, 99999, 99999, 99999 };  // minutos restantes de cada alarme
bool agora1 = false, agora2 = false, agora3 = false, agora4 = false, agora5 = false, agora6 = false;

// Estrutura para áreas clicáveis
struct TouchArea {
  int x1, y1, x2, y2;
  AppScreen origem;
  AppScreen destino;
};

// 🔒 Controle interno de toque (evita repetição)
bool toqueAtivo = false;     // houve toque na leitura atual
bool toqueAnterior = false;  // havia toque na leitura passada

bool podeSalvarAlarme(int numAlarme) {
  // Índices em arrays são 0..5 enquanto numAlarme é 1..6
  int idxEdit = numAlarme - 1;
  int hEdit = horasAlarme[idxEdit];
  int mEdit = minutosAlarme[idxEdit];

  // Validação de intervalo: aceitar 0..23 e 0..59 (00:00 é válido)
  if (hEdit < 0 || hEdit > 23) return false;
  if (mEdit < 0 || mEdit > 59) return false;

  // Verifica conflito com outros alarmes ATIVOS
  for (int i = 0; i < 6; i++) {
    if (i == idxEdit) continue;         // ignora o próprio
    if (!alarmeAtivo(i + 1)) continue;  // pula alarmes inativos (se sua função existir)
    if (horasAlarme[i] == hEdit && minutosAlarme[i] == mEdit) {
      // conflito direto — já existe outro alarme ativo com mesma hora/minuto
      return false;
    }
  }

  // tudo OK
  return true;
}


byte rtcDia, rtcMes, rtcHora, rtcMin;
int rtcAno;
char diaStr[4], mesStr[4], anoStr[6], horaStrRTC[4], minStrRTC[4];

// Variaveis de tempo
unsigned long lastUpdateScreenTime = 0;
unsigned long lastTemperaturaTime = 0;
const unsigned long intervalUpdateScreen = 1000;  // 1 segundo para updateScreenHome
const unsigned long intervalTemperatura = 10000;  // 10 segundos para temperaturaHome

char textosAlarme[6][100];  // 6 textos de até 99 caracteres cada

const char exemplo1[] = "DIGITE SEU REMEDIO EX: SAXENDA";
const char exemplo2[] = "DIGITE SEU REMEDIO EX: GLIFAGE";
const char exemplo3[] = "DIGITE SEU REMEDIO EX: FORXIGA";
const char exemplo4[] = "DIGITE SEU REMEDIO EX: OZEMPIC";
const char exemplo5[] = "DIGITE SEU REMEDIO EX: DORFLEX";
const char exemplo6[] = "DIGITE SEU REMEDIO EX: MORFINA";

struct AlarmeInfo {
  int id;                  // índice 1..6
  int x, y;                // posição na HOME
  const uint16_t* imagem;  // ícone da HOME

  String nome;        // nome carregado do EEPROM
  uint16_t corTexto;  // cor do texto na HOME
  uint16_t corLed;    // cor do alerta

  byte hora;    // hora carregada
  byte minuto;  // minuto carregado
  byte ciclo;   // ciclo em horas (0 = diário)
  bool ativo;   // estado ON/OFF
};
AlarmeInfo alarmesInfo[6] = {
  { 1, 20, 90, lixeira, "", WHITE, RED, 0, 0, 0, false },
  { 2, 175, 90, lixeira, "", WHITE, BEIGE, 0, 0, 0, false },
  { 3, 330, 90, lixeira, "", WHITE, MAGENTA, 0, 0, 0, false },
  { 4, 20, 208, lixeira, "", WHITE, ORANGE, 0, 0, 0, false },
  { 5, 175, 208, lixeira, "", BLACK, GREEN, 0, 0, 0, false },
  { 6, 330, 208, lixeira, "", BLACK, BLUE, 0, 0, 0, false }
};

const int reedPin6 = 29;
const int ledPin6 = 26;

const int reedPin3 = 33;  //deu no comparitmento 3(entao deve ser o alarme 3)
const int ledPin3 = 30;

const int reedPin5 = 37;  //deu no compartimento 5(entao deve ser o alarme 5)
const int ledPin5 = 34;

const int reedPin2 = 41;  //deu no compartimento 2(entao deve ser o alarme 2)
const int ledPin2 = 38;

const int reedPin4 = 45;  // deu no compartimento 4( entao deve ser o alarme 4)
const int ledPin4 = 42;

const int reedPin1 = 49;
const int ledPin1 = 46;

int alarmeTocando = -1;

time_t proximaExecucao[6] = { 0, 0, 0, 0, 0, 0 };
// Controle "Agora por 5s"
unsigned long tempoPrimeiroAgora[6] = { 0, 0, 0, 0, 0, 0 };
const unsigned long AGORA_DEBOUNCE_MS = 5000UL;  // 5 segundos

// LED / REED runtime
bool compartimentoAberto = false;
bool horaDoRemedio = false;
bool ledLigado = false;
unsigned long ultimoBlink = 0;
const unsigned long intervaloBlink = 300;

// Debounce para reed (uso simples)
const unsigned long reedDebounceMs = 50;
int reedLastRead = HIGH;
int reedStableState = HIGH;
unsigned long reedLastChange = 0;

int leituraReedDebounced(int reedPin) {
  static int ultimoEstado = HIGH;
  static unsigned long ultimaMudanca = 0;
  const unsigned long debounceDelay = 50;

  int leitura = digitalRead(reedPin);

  if (leitura != ultimoEstado) {
    ultimaMudanca = millis();
    ultimoEstado = leitura;
  }

  if (millis() - ultimaMudanca > debounceDelay) {
    return leitura;
  }

  return ultimoEstado;
}
bool touchEmProgresso = false;

struct AlarmeTmp {
  String nome;
  byte hora;
  byte minuto;
  byte ciclo;
  bool ativo;
  int minutosRestantes;
  int indexOriginal;
  bool definido;
};

// global
AlarmeTmp temp[6];

// Mapeamento de áreas clicáveis
const TouchArea touchAreas[] = {

  { 420, 260, 472, 313, SCREEN_HOME, SCREEN_EDITOR },

  { 15, 260, 65, 313, SCREEN_EDITOR, SCREEN_HOME },

  { 30, 245, 80, 300, SCREEN_DEFAL1, SCREEN_EDITOR },

  { 30, 245, 80, 300, SCREEN_DEFAL2, SCREEN_EDITOR },

  { 30, 245, 80, 300, SCREEN_DEFAL3, SCREEN_EDITOR },

  { 30, 245, 80, 300, SCREEN_DEFAL4, SCREEN_EDITOR },

  { 30, 245, 80, 300, SCREEN_DEFAL5, SCREEN_EDITOR },

  { 30, 245, 80, 300, SCREEN_DEFAL6, SCREEN_EDITOR },

  { 80, 285, 115, 310, SCREEN_EDITOR, SCREEN_RESETALL },

  //lixeira do alarme 1
  { 125, 208, 125 + 25, 208 + 25, SCREEN_EDITOR, SCREEN_RESET1 },

  // lixeira do alarme 2
  { 280, 208, 280 + 25, 208 + 25, SCREEN_EDITOR, SCREEN_RESET2 },

  // lixeira do alarme 3
  { 435, 208, 435 + 25, 208 + 25, SCREEN_EDITOR, SCREEN_RESET3 },

  // lixeira do alarme 4
  { 125, 90, 125 + 25, 90 + 25, SCREEN_EDITOR, SCREEN_RESET4 },

  // lixeira do alarme 5
  { 280, 90, 280 + 25, 90 + 25, SCREEN_EDITOR, SCREEN_RESET5 },

  // lixeira do alarme 6
  { 435, 90, 435 + 25, 90 + 25, SCREEN_EDITOR, SCREEN_RESET6 },

  // abrir teclado do alarme 1
  { 400, 180, 435, 220, SCREEN_DEFAL1, SCREEN_KEYBOARD },

  // abrir teclado do alarme 2
  { 400, 180, 435, 220, SCREEN_DEFAL2, SCREEN_KEYBOARD },

  // abrir teclado do alarme 3
  { 400, 180, 435, 220, SCREEN_DEFAL3, SCREEN_KEYBOARD },

  // abrir teclado do alarme 4
  { 400, 180, 435, 220, SCREEN_DEFAL4, SCREEN_KEYBOARD },

  // abrir teclado do alarme 5
  { 400, 180, 435, 220, SCREEN_DEFAL5, SCREEN_KEYBOARD },

  // abrir teclado do alarme 6
  { 400, 180, 435, 220, SCREEN_DEFAL6, SCREEN_KEYBOARD },

  { 355, 260, 410, 313, SCREEN_HOME, SCREEN_INFO },

  { 30, 245, 80, 300, SCREEN_INFO, SCREEN_HOME },

  { 30, 245, 80, 300, SCREEN_CALIBRACAO, SCREEN_INFO }

};



// Protótipos das funções
void Home();
void Editor();
void transitionToScreen(AppScreen newScreen);
void gerarListaAlarmesOrdenados();
void atualizarAlarmesHome();
void lertemperaturaHome();
void lertemperaturaEditor();
void updateHomeScreen();
void navigateToScreen(AppScreen newScreen);
uint16_t ID;
uint16_t colors[10] = { BLACK, WHITE, YELLOW, CYAN, GREEN, MAGENTA, RED, BLUE, PURPLE };



void setup() {
  Serial.begin(115200);
  Serial3.begin(115200);
  inicializarEEPROM();
  carregarEstados();
  mostrarEEPROM();
  tft.reset();
  ID = tft.readID();
  Serial.print(F("TFT ID = 0x"));
  Serial.println(ID, HEX);
  //    if (ID == 0xD3D3) ID = 0x9481; // write-only shield
  if (ID == 0xD3D3) ID = 0x6814;  // write-only shield
  tft.begin(ID);
  tft.invertDisplay(false);
  tft.setFont(&FreeSans9pt7b);
  tft.setRotation(1);
  tft.fillScreen(WHITE);
  // Verificação visual da inicialização
  inicializacao();
  Serial.println(F("Sistema inicializado com sucesso!"));
  // Agora chama a tela inicial
  verificarStatusRTC();
  switch (currentScreen) {
    case SCREEN_HOME:
      Home();
  }
}



void loop() {
  // --- Sincroniza tempo global + Agora ---
  verificarStatusRTC();
  atualizarTempoEAgora();
  checarAlarmesAgora();
  delay(200);
  processarTouch();
  unsigned long currentMillis = millis();
  // --- Atualização da tela HOME a cada 1s ---
  if (currentMillis - lastUpdateScreenTime >= intervalUpdateScreen) {
    lastUpdateScreenTime = currentMillis;
    updateHomeScreen();
  }

  // --- Atualização de temperatura a cada 10s ---
  if (currentMillis - lastTemperaturaTime >= intervalTemperatura) {
    lastTemperaturaTime = currentMillis;
    lertemperaturaHome();
    lertemperaturaEditor();
  }

  // --- Comunicação MEGA → ESP ---
  if (Serial.available()) {
    String comando = Serial.readStringUntil('\n');
    comando.trim();

    if (comando.length() > 0) {
      Serial3.println(comando);
      Serial.print(F("Enviado ao ESP8266: "));
      Serial.println(comando);
    }
  }

  // --- Comunicação ESP → MEGA ---
  if (Serial3.available()) {
    String resposta = Serial3.readStringUntil('\n');
    resposta.trim();

    if (resposta.length() > 0) {
      Serial.print(F("Resposta do ESP8266/ESP32: "));
      Serial.println(resposta);
    }
  }
}



//EEPROM
void carregarAlarmesDaEEPROM() {
  for (int i = 0; i < 6; i++) {
    // Lê do EEPROM para o struct "alarmes"
    char buffer[100];
    EEPROM.get(ADDR_TEXTO1 + i * 100, buffer);
    buffer[sizeof(buffer) - 1] = '\0';
    alarmes[i].nome = String(buffer);

    alarmes[i].hora = EEPROM.read(ADDR_HORA1 + i * 10);
    alarmes[i].minuto = EEPROM.read(ADDR_MIN1 + i * 10);
    alarmes[i].ciclo = EEPROM.read(ADDR_CICLO_ALARME1 + i);
    alarmes[i].ativo = alarmeAtivo(i + 1);

    // Cálculo de próxima execução
    if (alarmes[i].ativo) {
      time_t now = RTC.get();
      tmElements_t tmNow;
      breakTime(now, tmNow);

      tmElements_t tmAlarm;
      tmAlarm.Hour = alarmes[i].hora;
      tmAlarm.Minute = alarmes[i].minuto;
      tmAlarm.Second = 0;
      tmAlarm.Day = tmNow.Day;
      tmAlarm.Month = tmNow.Month;
      tmAlarm.Year = tmNow.Year + 1970;

      time_t alarmeTime = makeTime(tmAlarm);

      if (alarmeTime <= now && alarmes[i].ciclo > 0) {
        alarmeTime += (alarmes[i].ciclo * 3600);
      }
      alarmes[i].proximaExecucao = alarmeTime;
    } else {
      alarmes[i].proximaExecucao = 0;
    }

    // --- Copia para alarmesInfo mantendo cores e id ---
    alarmesInfo[i].nome = alarmes[i].nome;
    alarmesInfo[i].hora = alarmes[i].hora;
    alarmesInfo[i].minuto = alarmes[i].minuto;
    alarmesInfo[i].ciclo = alarmes[i].ciclo;
    alarmesInfo[i].ativo = alarmes[i].ativo;
    alarmesInfo[i].id = i + 1;  // ou mantenha o id existente
    // corTexto e corLed permanecem os mesmos
  }
}



void ordenarAlarmesPorProximidade() {
  // Ordena os alarmes ativos pelo tempo restante
  for (int i = 0; i < 5; i++) {
    for (int j = i + 1; j < 6; j++) {
      if (alarmes[i].proximaExecucao == 0) continue;
      if (alarmes[j].proximaExecucao == 0) continue;
      if (alarmes[j].proximaExecucao < alarmes[i].proximaExecucao) {
        AlarmeRTC temp = alarmes[i];
        alarmes[i] = alarmes[j];
        alarmes[j] = temp;
      }
    }
  }
}

void inicializarEEPROM() {
  // Inicializa valores de alarme ON/OFF e delete
  const int enderecos[] = {
    ADDR_ALARME1, ADDR_ALARME2, ADDR_ALARME3,
    ADDR_ALARME4, ADDR_ALARME5, ADDR_ALARME6,
    ADDR_DELALARM1, ADDR_DELALARM2, ADDR_DELALARM3,
    ADDR_DELALARM4, ADDR_DELALARM5, ADDR_DELALARM6
  };

  for (int i = 0; i < sizeof(enderecos) / sizeof(int); i++) {
    if (EEPROM.read(enderecos[i]) == 0xFF) {
      EEPROM.update(enderecos[i], 0);
    }
  }

  // Inicializa textos se estiverem vazios
  for (int i = 0; i < 6; i++) {
    char buffer[100];
    EEPROM.get(ADDR_TEXTO1 + i * 100, buffer);
    if (buffer[0] == 0xFF || buffer[0] == '\0') {
      buffer[0] = '\0';
      EEPROM.put(ADDR_TEXTO1 + i * 100, buffer);
    }
  }

  // Inicializa horas e minutos dos alarmes
  const int enderecosHoraMin[] = {
    ADDR_HORA1, ADDR_MIN1, ADDR_HORA2, ADDR_MIN2,
    ADDR_HORA3, ADDR_MIN3, ADDR_HORA4, ADDR_MIN4,
    ADDR_HORA5, ADDR_MIN5, ADDR_HORA6, ADDR_MIN6
  };
  for (int i = 0; i < sizeof(enderecosHoraMin) / sizeof(int); i++) {
    if (EEPROM.read(enderecosHoraMin[i]) == 0xFF) {
      EEPROM.update(enderecosHoraMin[i], 0);
    }
  }

  // 🔄 Inicializa ciclos dos alarmes
  const int enderecosCiclo[] = {
    ADDR_CICLO_ALARME1, ADDR_CICLO_ALARME2, ADDR_CICLO_ALARME3,
    ADDR_CICLO_ALARME4, ADDR_CICLO_ALARME5, ADDR_CICLO_ALARME6
  };

  for (int i = 0; i < 6; i++) {
    // Se valor da EEPROM ainda não foi escrito, define 0
    if (EEPROM.read(enderecosCiclo[i]) == 0xFF) {
      EEPROM.update(enderecosCiclo[i], 0);
    }

    // 🔍 Se o alarme correspondente estiver desativado, também zera o ciclo
    uint8_t alarmeAtivo = EEPROM.read(ADDR_ALARME1 + i);
    if (alarmeAtivo == 0) {
      definirCicloAlarme(i + 1, 0);
      EEPROM.update(enderecosCiclo[i], 0);
      Serial.print(F("Ciclo do alarme "));
      Serial.print(i + 1);
      Serial.println(F(" resetado (alarme desativado)."));
    }
  }

  // 🕒 Inicializa data/hora padrão se estiverem zeradas
  if (rtcDia == 0 && rtcMes == 0 && rtcAno == 0 && rtcHora == 0 && rtcMin == 0) {
    rtcDia = 1;
    rtcMes = 1;
    rtcAno = 2025;
    rtcHora = 0;
    rtcMin = 0;

    Serial.println(F("RTC zerado detectado — valores padrão aplicados."));
    Serial.print(F("Data inicial: "));
    Serial.print(rtcDia);
    Serial.print(F("/"));
    Serial.print(rtcMes);
    Serial.print(F("/"));
    Serial.println(rtcAno);
    Serial.print(F("Hora inicial: "));
    Serial.print(rtcHora);
    Serial.print(F(":"));
    Serial.println(rtcMin);
  }
}




void mostrarEEPROM() {
  Serial.println(F("\nConteúdo da EEPROM:"));
  Serial.println(F("Endereço | Valor"));
  Serial.println(F("----------------"));

  for (int i = 0; i <= 12; i++) {
    Serial.print(i);
    Serial.print(F("\t | "));
    Serial.println(EEPROM.read(i));
  }

  Serial.println(F("\nTextos dos alarmes:"));
  for (int i = 0; i < 6; i++) {
    char buffer[100];
    EEPROM.get(ADDR_TEXTO1 + i * 100, buffer);
    buffer[sizeof(buffer) - 1] = '\0';
    Serial.print(F("Alarme "));
    Serial.print(i + 1);
    Serial.print(F(": "));
    Serial.println(buffer);
  }

  Serial.println(F("\nHorários dos alarmes:"));
  for (int i = 0; i < 6; i++) {
    byte h = EEPROM.read(ADDR_HORA1 + i * 10);
    byte m = EEPROM.read(ADDR_MIN1 + i * 10);
    Serial.print(F("Alarme "));
    Serial.print(i + 1);
    Serial.print(F(": "));
    if (h < 10) Serial.print("0");
    Serial.print(h);
    Serial.print(F(":"));
    if (m < 10) Serial.print("0");
    Serial.println(m);
  }

  Serial.println(F("\nCiclos dos alarmes:"));
  for (int i = 0; i < 6; i++) {
    byte ciclo = EEPROM.read(ADDR_CICLO_ALARME1 + i);
    Serial.print(F("Alarme "));
    Serial.print(i + 1);
    Serial.print(F(": "));
    if (ciclo == 0)
      Serial.println(F("Sem ciclo ativo"));
    else {
      Serial.print(ciclo);
      Serial.println(F("h"));
    }
  }
  Serial.println(F("\nConfiguração de Calibração RTC:"));
  Serial.print(F("Data: "));
  Serial.print(rtcDia);
  Serial.print(F("/"));
  Serial.print(rtcMes);
  Serial.print(F("/"));
  Serial.println(rtcAno);
  Serial.print(F("Hora: "));
  Serial.print(rtcHora);
  Serial.print(F(":"));
  Serial.println(rtcMin);
}
// Função para carregar todos os estados da EEPROM
void carregarEstados() {
  ALARME1 = EEPROM.read(ADDR_ALARME1);
  ALARME2 = EEPROM.read(ADDR_ALARME2);
  ALARME3 = EEPROM.read(ADDR_ALARME3);
  ALARME4 = EEPROM.read(ADDR_ALARME4);
  ALARME5 = EEPROM.read(ADDR_ALARME5);
  ALARME6 = EEPROM.read(ADDR_ALARME6);

  DELALARM1 = EEPROM.read(ADDR_DELALARM1);
  DELALARM2 = EEPROM.read(ADDR_DELALARM2);
  DELALARM3 = EEPROM.read(ADDR_DELALARM3);
  DELALARM4 = EEPROM.read(ADDR_DELALARM4);
  DELALARM5 = EEPROM.read(ADDR_DELALARM5);
  DELALARM6 = EEPROM.read(ADDR_DELALARM6);

  // Carregar textos
  for (int i = 0; i < 6; i++) {
    EEPROM.get(ADDR_TEXTO1 + i * 100, textosAlarme[i]);
    textosAlarme[i][sizeof(textosAlarme[i]) - 1] = '\0';  // segurança

    // se o alarme estiver desligado, apaga texto
    bool alarmeAtivo;
    switch (i + 1) {
      case 1: alarmeAtivo = ALARME1; break;
      case 2: alarmeAtivo = ALARME2; break;
      case 3: alarmeAtivo = ALARME3; break;
      case 4: alarmeAtivo = ALARME4; break;
      case 5: alarmeAtivo = ALARME5; break;
      case 6: alarmeAtivo = ALARME6; break;
    }
    if (!alarmeAtivo) {
      strcpy_P(textosAlarme[i], PSTR(""));
      EEPROM.put(ADDR_TEXTO1 + i * 100, textosAlarme[i]);
      Serial.print(F("Edição do alarme "));
      Serial.print(i + 1);
      Serial.println(F(" desbloqueada (texto apagado)."));
    }
  }

  // Carregar horas/minutos
  horasAlarme[0] = EEPROM.read(ADDR_HORA1);
  minutosAlarme[0] = EEPROM.read(ADDR_MIN1);
  horasAlarme[1] = EEPROM.read(ADDR_HORA2);
  minutosAlarme[1] = EEPROM.read(ADDR_MIN2);
  horasAlarme[2] = EEPROM.read(ADDR_HORA3);
  minutosAlarme[2] = EEPROM.read(ADDR_MIN3);
  horasAlarme[3] = EEPROM.read(ADDR_HORA4);
  minutosAlarme[3] = EEPROM.read(ADDR_MIN4);
  horasAlarme[4] = EEPROM.read(ADDR_HORA5);
  minutosAlarme[4] = EEPROM.read(ADDR_MIN5);
  horasAlarme[5] = EEPROM.read(ADDR_HORA6);
  minutosAlarme[5] = EEPROM.read(ADDR_MIN6);
}
void carregarRTCConfig() {
  rtcDia = EEPROM.read(ADDR_RTC_DIA);
  rtcMes = EEPROM.read(ADDR_RTC_MES);
  EEPROM.get(ADDR_RTC_ANO, rtcAno);
  rtcHora = EEPROM.read(ADDR_RTC_HORA);
  rtcMin = EEPROM.read(ADDR_RTC_MIN);
}


//Alarmes
void salvarAlarme(int numAlarme, bool valor) {
  if (numAlarme < 1 || numAlarme > 6) {
    Serial.println(F("Número de alarme inválido!"));
    return;
  }

  int idx = numAlarme - 1;

  // 1) Grava apenas a flag de ativo/inativo no endereço dedicado
  switch (numAlarme) {
    case 1:
      EEPROM.update(ADDR_ALARME1, valor);
      ALARME1 = valor;
      break;
    case 2:
      EEPROM.update(ADDR_ALARME2, valor);
      ALARME2 = valor;
      break;
    case 3:
      EEPROM.update(ADDR_ALARME3, valor);
      ALARME3 = valor;
      break;
    case 4:
      EEPROM.update(ADDR_ALARME4, valor);
      ALARME4 = valor;
      break;
    case 5:
      EEPROM.update(ADDR_ALARME5, valor);
      ALARME5 = valor;
      break;
    case 6:
      EEPROM.update(ADDR_ALARME6, valor);
      ALARME6 = valor;
      break;
  }

  // 2) GARANTIA: sempre escrevemos a hora/minuto/ciclo atuais da RAM na EEPROM
  //    Assim evitamos inconsistências (especialmente se o valor em RAM foi atualizado pelo editor).
  //    Endereços esperados: ADDR_HORA1 + idx*10, ADDR_MIN1 + idx*10, ADDR_CICLO_ALARME1 + idx
  byte h = (byte)horasAlarme[idx];
  byte m = (byte)minutosAlarme[idx];
  byte c = (byte)cicloAlarme[idx];

  EEPROM.update(ADDR_HORA1 + idx * 10, h);
  EEPROM.update(ADDR_MIN1 + idx * 10, m);
  EEPROM.update(ADDR_CICLO_ALARME1 + idx, c);

  // 3) Ler de volta para RAM (sincroniza e evita leitura de dados errados)
  horasAlarme[idx] = EEPROM.read(ADDR_HORA1 + idx * 10);
  minutosAlarme[idx] = EEPROM.read(ADDR_MIN1 + idx * 10);
  cicloAlarme[idx] = EEPROM.read(ADDR_CICLO_ALARME1 + idx);

  // Debug útil
  Serial.print(F("salvarAlarme(): alarme "));
  Serial.print(numAlarme);
  Serial.print(F(" ativo="));
  Serial.print(valor);
  Serial.print(F(" hora="));
  Serial.print(horasAlarme[idx]);
  Serial.print(F(" min="));
  Serial.print(minutosAlarme[idx]);
  Serial.print(F(" ciclo="));
  Serial.println(cicloAlarme[idx]);
}

//Lixeiras
void salvarDelAlarm(int numDelAlarm, bool valor) {
  switch (numDelAlarm) {
    case 1:
      EEPROM.update(ADDR_DELALARM1, valor);
      break;
    case 2:
      EEPROM.update(ADDR_DELALARM2, valor);
      break;
    case 3:
      EEPROM.update(ADDR_DELALARM3, valor);
      break;
    case 4:
      EEPROM.update(ADDR_DELALARM4, valor);
      break;
    case 5:
      EEPROM.update(ADDR_DELALARM5, valor);
      break;
    case 6:
      EEPROM.update(ADDR_DELALARM6, valor);
      break;
    default:
      Serial.print(F("Erro: DELALARM "));
      Serial.print(numDelAlarm);
      Serial.println(F(" inválido!"));
      break;
  }
}
bool alarmeAtivo(int id) {
  switch (id) {
    case 1: return ALARME1 == 1;
    case 2: return ALARME2 == 1;
    case 3: return ALARME3 == 1;
    case 4: return ALARME4 == 1;
    case 5: return ALARME5 == 1;
    case 6: return ALARME6 == 1;
    default: return false;
  }
}



//Touch
bool botaoPertenceATela(int i) {

  // 🔹 Tela Home
  if (currentScreen == SCREEN_HOME) {
    return (i == 98 || i == 97);
  }
  if (currentScreen == SCREEN_INFO) {
    return (i == 99 || i == 100);
  }
  if (currentScreen == SCREEN_INFO1) {
    return (i == 101 || i == 102);
  }
  if (currentScreen == SCREEN_INFO2) {
    return i == 103;
  }
  // 🔹 Tela Calibração
  if (currentScreen == SCREEN_CALIBRACAO) {
    return i >= 104 && i <= 114;
  }
  // 🔹 Tela Editor
  if (currentScreen == SCREEN_EDITOR) {
    return i >= 0 && i <= 5;
  }

  // 🔹 Telas DEFAL1 a DEFAL6
  if (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6) {
    int esperadoOK = currentScreen - SCREEN_DEFAL1 + 6;

    // identifica botões + e - de cada DEFAL
    int base = 55 + (currentScreen - SCREEN_DEFAL1) * 4;  // ex: DEFAL1 → 55, DEFAL2 → 59
    int topo = base + 3;

    // ✅ --- Botões extras por tela DEFAL ---
    const int botoesExtrasDEFAL1[] = { 79, 80, 81 };
    const int botoesExtrasDEFAL2[] = { 82, 83, 84 };
    const int botoesExtrasDEFAL3[] = { 85, 86, 87 };
    const int botoesExtrasDEFAL4[] = { 88, 89, 90 };
    const int botoesExtrasDEFAL5[] = { 91, 92, 93 };
    const int botoesExtrasDEFAL6[] = { 94, 95, 96 };

    const int* extras = nullptr;
    int qtdExtras = 0;

    switch (currentScreen) {
      case SCREEN_DEFAL1:
        extras = botoesExtrasDEFAL1;
        qtdExtras = sizeof(botoesExtrasDEFAL1) / sizeof(int);
        break;
      case SCREEN_DEFAL2:
        extras = botoesExtrasDEFAL2;
        qtdExtras = sizeof(botoesExtrasDEFAL2) / sizeof(int);
        break;
      case SCREEN_DEFAL3:
        extras = botoesExtrasDEFAL3;
        qtdExtras = sizeof(botoesExtrasDEFAL3) / sizeof(int);
        break;
      case SCREEN_DEFAL4:
        extras = botoesExtrasDEFAL4;
        qtdExtras = sizeof(botoesExtrasDEFAL4) / sizeof(int);
        break;
      case SCREEN_DEFAL5:
        extras = botoesExtrasDEFAL5;
        qtdExtras = sizeof(botoesExtrasDEFAL5) / sizeof(int);
        break;
      case SCREEN_DEFAL6:
        extras = botoesExtrasDEFAL6;
        qtdExtras = sizeof(botoesExtrasDEFAL6) / sizeof(int);
        break;
    }

    // Se o botão é o OK, +, -, ou qualquer um do intervalo padrão
    if ((i == esperadoOK) || (i >= base && i <= topo)) {
      return true;
    }

    // Se é um dos botões extras
    for (int j = 0; j < qtdExtras; j++) {
      if (i == extras[j]) return true;
    }

    return false;
  }

  // 🔹 Telas RESET
  if (currentScreen == SCREEN_RESETALL) return i == 12 || i == 13;
  if (currentScreen == SCREEN_RESET1) return i == 14 || i == 15;
  if (currentScreen == SCREEN_RESET2) return i == 16 || i == 17;
  if (currentScreen == SCREEN_RESET3) return i == 18 || i == 19;
  if (currentScreen == SCREEN_RESET4) return i == 20 || i == 21;
  if (currentScreen == SCREEN_RESET5) return i == 22 || i == 23;
  if (currentScreen == SCREEN_RESET6) return i == 24 || i == 25;

  // 🔹 Teclado
  if (currentScreen == SCREEN_KEYBOARD) {
    return i >= 26 && i <= 55;
  }

  return false;
}


// Reseta hora, minuto e texto do alarme
void resetAlarme(int alarmeId) {
  if (alarmeId < 1 || alarmeId > 6) return;

  // Reseta hora e minuto
  horasAlarme[alarmeId - 1] = 0;
  minutosAlarme[alarmeId - 1] = 0;
  EEPROM.update(ADDR_HORA1 + (alarmeId - 1) * 10, 0);
  EEPROM.update(ADDR_MIN1 + (alarmeId - 1) * 10, 0);

  // Reseta nome do alarme
  textosAlarme[alarmeId - 1][0] = '\0';
  int addrTexto = ADDR_TEXTO1 + (alarmeId - 1) * 10;
  for (int i = 0; i < 10; i++) EEPROM.update(addrTexto + i, 0);

  // Reseta flag de inicialização
  switch (alarmeId) {
    case 1: jaInicializouHorario1 = false; break;
    case 2: jaInicializouHorario2 = false; break;
    case 3: jaInicializouHorario3 = false; break;
    case 4: jaInicializouHorario4 = false; break;
    case 5: jaInicializouHorario5 = false; break;
    case 6: jaInicializouHorario6 = false; break;
  }

  Serial.print(F("Alarme "));
  Serial.print(alarmeId);
  Serial.println(F(" resetado!"));
}

// Retorna true se o alarme pode ser resetado (ativo)
bool isAlarmeResetavel(int alarmeId) {
  if (alarmeId < 1 || alarmeId > 6) return false;
  return alarmeAtivo(alarmeId);
}

void processarTouch() {
  TSPoint p = ts.getPoint();

  // Reconfigura pinos após leitura
  pinMode(XM, OUTPUT);
  digitalWrite(XM, LOW);
  pinMode(YP, OUTPUT);
  digitalWrite(YP, HIGH);
  pinMode(YM, OUTPUT);
  digitalWrite(YM, LOW);
  pinMode(XP, OUTPUT);
  digitalWrite(XP, HIGH);

  bool touchDetected = (p.z > MINPRESSURE && p.z < MAXPRESSURE);

  // 🟡 Quando não há toque, libera atualização
  if (!touchDetected) {
    touchEmProgresso = false;
    return;
  }

  // 🟢 Há toque ativo
  touchEmProgresso = true;

  // Corrige mapeamento para landscape
  int x = map(p.y, TS_MINY, TS_MAXY, SCREEN_WIDTH, 0);
  int y = map(p.x, TS_MINX, TS_MAXX, 0, SCREEN_HEIGHT);
  x = constrain(x, 0, SCREEN_WIDTH);
  y = constrain(y, 0, SCREEN_HEIGHT);

  Serial.print(F("X: "));
  Serial.print(x);
  Serial.print(F(" / Y: "));
  Serial.println(y);
  Serial.print(F("currentScreen: "));
  Serial.println(currentScreen);

  // --- BACK / reset nas telas DEFALn ---
  if (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6) {
    if (x >= 80 && x <= 115 && y >= 285 && y <= 310) {
      Serial.println(F("🟢 RESETALL acionado!"));
      int alarmeId = currentScreen - SCREEN_DEFAL1 + 1;
      resetAlarme(alarmeId);
      navigateToScreen(SCREEN_EDITOR);
      delay(200);
      return;
    }
  }

  // --- Processa áreas de toque ---
  for (int i = 0; i < sizeof(touchAreas) / sizeof(TouchArea); i++) {
    TouchArea area = touchAreas[i];
    if (area.origem != currentScreen) continue;

    if (area.destino >= SCREEN_RESET1 && area.destino <= SCREEN_RESET6) {
      int alarmeId = area.destino - SCREEN_RESET1 + 1;
      if (!isAlarmeResetavel(alarmeId)) {
        Serial.print(F("Reset bloqueado: alarme "));
        Serial.println(alarmeId);
        continue;
      }
    }

    if (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6 && area.destino == SCREEN_KEYBOARD) {
      if (x >= area.x1 && x <= area.x2 && y >= area.y1 && y <= area.y2) {
        int alarmeId = currentScreen - SCREEN_DEFAL1 + 1;
        if (alarmeAtivo(alarmeId)) {
          Serial.println(F("Alarme já definido, bloqueando edição."));
          continue;
        }
        alarmeEditando = alarmeId;
        telaOrigem = currentScreen;
        navigateToScreen(SCREEN_KEYBOARD);
        delay(200);
        return;
      }
    }

    if (x >= area.x1 && x <= area.x2 && y >= area.y1 && y <= area.y2) {
      Serial.print(F("Clique válido, indo para destino "));
      Serial.println(area.destino);
      navigateToScreen(area.destino);
      delay(200);
      return;
    }
  }

  // --- Botões visuais ---
  y = SCREEN_HEIGHT - y;
  verificarToqueNosBotoes(x, y);
}



void desmarcarBotoesAtuais() {
  bool telaEhDefal = (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6);
  int indiceTela = telaEhDefal ? currentScreen - SCREEN_DEFAL1 : -1;
  int toggleAtivo = telaEhDefal ? ultimoToggleAtivoPorTela[indiceTela] : -1;

  for (int i = 0; i < NUM_BOTOES; i++) {
    if (!botaoPertenceATela(i)) continue;

    Botao& btn = botoes[i];

    if (btn.pressionado && (!btn.toggle || !telaEhDefal || btn.indice != toggleAtivo)) {
      btn.pressionado = false;
      desenharBotao(btn);
    }
  }
}
void verificarToqueNosBotoes(int x, int y) {
  int xAjustado = x;

  // 👉 Aplica o ajuste em todas as telas, EXCETO na tela de edição e no teclado
  if (currentScreen != SCREEN_EDITOR) {
    xAjustado -= 10;
  }

  for (int i = 0; i < NUM_BOTOES; i++) {
    if (!botaoPertenceATela(i)) continue;

    Botao& btn = botoes[i];

    // ⚙️ Ignora toques em botões travados nas telas que usam travamento
    bool usaTravamento = (currentScreen == SCREEN_HOME || currentScreen == SCREEN_CALIBRACAO || (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6));

    if (usaTravamento && btn.ativo) continue;  // trava apenas nessas telas
    // 🖐️ Verifica se o toque está dentro do botão
    if (xAjustado >= btn.x && xAjustado <= btn.x + btn.largura && y >= btn.y && y <= btn.y + btn.altura) {

      bool telaEhDefal = (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6);

      // --- 🟢 TOGGLE ---
      if (btn.toggle) {
        if (telaEhDefal) {
          int indiceTela = currentScreen - SCREEN_DEFAL1;
          int toggleAtivo = ultimoToggleAtivoPorTela[indiceTela];

          if (toggleAtivo == btn.indice) {
            btn.pressionado = false;
            desenharBotao(btn);
            ultimoToggleAtivoPorTela[indiceTela] = -1;
            atualizarTextoCiclo(indiceTela);
            delay(150);
            return;
          }

          if (toggleAtivo != -1 && toggleAtivo != btn.indice) {
            for (int j = 0; j < NUM_BOTOES; j++) {
              if (botoes[j].indice == toggleAtivo) {
                botoes[j].pressionado = false;
                desenharBotao(botoes[j]);
                break;
              }
            }
          }

          btn.pressionado = true;
          desenharBotao(btn);
          ultimoToggleAtivoPorTela[indiceTela] = btn.indice;
          atualizarTextoCiclo(indiceTela);
          executarAcao(btn.indice);
          delay(150);
          return;
        }

        // Toggle comum
        btn.pressionado = !btn.pressionado;
        desenharBotao(btn);
        executarAcao(btn.indice);
        delay(150);
        return;
      }

      // --- 🔵 NORMAL ---
      desmarcarBotoesAtuais();
      btn.pressionado = true;
      desenharBotao(btn);

      if (currentScreen == SCREEN_KEYBOARD)
        processarTecla(btn.texto);
      else
        executarAcao(btn.indice);
      delay(200);
      btn.pressionado = false;
      desenharBotao(btn);
      return;
    }
  }
}




void atualizarAlarmesHome() {
  gerarListaAlarmesOrdenados();
}
//Definição de Telas

void updateHomeScreen() {
  if (currentScreen != SCREEN_HOME) return;
  if (touchEmProgresso) return;

  static unsigned long ultimoTroca = 0;
  static bool mostrandoData = false;

  time_t now = RTC.get();
  unsigned long tempoAtual = millis();

  // --- alterna entre hora e data ---
  if (!mostrandoData && (tempoAtual - ultimoTroca >= INTERVALO_TROCA_PARA_DATA)) {
    mostrandoData = true;
    ultimoTroca = tempoAtual;
  } else if (mostrandoData && (tempoAtual - ultimoTroca >= DURACAO_EXIBICAO_DATA)) {
    mostrandoData = false;
    ultimoTroca = tempoAtual;
  }

  // --- formata o texto mostrado ---
  char buffer[16];
  if (mostrandoData) {
    int ano2dig = year(now) % 100;  // só últimos dois dígitos do ano
    sprintf_P(buffer, PSTR("%02d/%02d/%02d"), day(now), month(now), ano2dig);
  } else {
    sprintf_P(buffer, PSTR("%02d:%02d:%02d"), hour(now), minute(now), second(now));
  }

  // --- renderiza o texto ---
  tft.setCursor(52, 204);
  tft.setTextColor(BLACK);
  tft.setTextSize(2);
  tft.fillRoundRect(53, 173, 145, 40, 20, WHITE);
  tft.println(buffer);

  // 🕐 Atualiza lista de alarmes apenas quando o minuto muda
  if (minute(now) != ultimoMinutoAtualizado) {
    ultimoMinutoAtualizado = minute(now);
    atualizarAlarmesHome();
  }
}
void navigateToScreen(AppScreen newScreen) {
  if (currentScreen == newScreen) return;
  lastScreen = currentScreen;  // salva a tela atual antes de trocar  // Já está na tela
  currentScreen = newScreen;

  inicializaBotoes();  // <- sempre redefine os dados dos botões

  switch (currentScreen) {
    case SCREEN_HOME:
      telaOrigem = currentScreen;
      Home();
      break;
    case SCREEN_EDITOR:
      telaOrigem = currentScreen;
      Editor();


      break;
    case SCREEN_DEFAL1:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario1) {
        jaInicializouHorario1 = true;
      }
      ConfigAlarme1();
      textoDigitado[0] = '\0';
      break;

    case SCREEN_DEFAL2:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario2) {
        jaInicializouHorario2 = true;
      }
      ConfigAlarme2();
      textoDigitado[0] = '\0';
      break;

    case SCREEN_DEFAL3:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario3) {
        jaInicializouHorario3 = true;
      }
      ConfigAlarme3();
      textoDigitado[0] = '\0';
      break;

    case SCREEN_DEFAL4:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario4) {
        jaInicializouHorario4 = true;
      }
      ConfigAlarme4();
      textoDigitado[0] = '\0';
      break;

    case SCREEN_DEFAL5:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario5) {
        jaInicializouHorario5 = true;
      }
      ConfigAlarme5();
      textoDigitado[0] = '\0';
      break;

    case SCREEN_DEFAL6:
      telaOrigem = currentScreen;
      if (!jaInicializouHorario6) {
        jaInicializouHorario6 = true;
      }
      ConfigAlarme6();
      textoDigitado[0] = '\0';
      break;
    case SCREEN_RESETALL:
      telaOrigem = currentScreen;
      ResetAll();
      break;
    case SCREEN_RESET1:
      telaOrigem = currentScreen;
      ResetAlarme1();
      break;
    case SCREEN_RESET2:
      telaOrigem = currentScreen;
      ResetAlarme2();
      break;
    case SCREEN_RESET3:
      telaOrigem = currentScreen;
      ResetAlarme3();
      break;
    case SCREEN_RESET4:
      telaOrigem = currentScreen;
      ResetAlarme4();
      break;
    case SCREEN_RESET5:
      telaOrigem = currentScreen;
      ResetAlarme5();
      break;
    case SCREEN_RESET6:
      telaOrigem = currentScreen;
      ResetAlarme6();
      break;
    case SCREEN_KEYBOARD:
      keyboard();
      redesenharCampoTexto();
      break;
    case SCREEN_ERRODEF:
      telaOrigem = currentScreen;
      ERRODEF();
      break;
    case SCREEN_INFO:
      telaOrigem = currentScreen;
      screeninfo();
      break;
    case SCREEN_INFO1:
      telaOrigem = currentScreen;
      screeninfo1();
      break;
    case SCREEN_CALIBRACAO:
      telaOrigem = currentScreen;
      screencalibracao();
      break;
    case SCREEN_ALARMETOCANDO:

      if (!rtcDisponivel || !rtcCalibrado) {
        currentScreen = SCREEN_HOME;
        break;
      }

      if (currentScreen == SCREEN_CALIBRACAO) {
        currentScreen = SCREEN_HOME;
        break;
      }

      screenalarmetocando(alarmeTocando);
      break;
  }
  desenharTodosBotoes();  // Agora desenha os botões da tela correta
}
void transitionToScreen(AppScreen newScreen) {
  // Animação de deslize (simplificada)
  for (int i = 0; i < tft.width(); i += 5) {
    tft.fillRect(i, 0, 5, tft.height(), WHITE);
    delay(10);
  }

  navigateToScreen(newScreen);  // já inicializa e desenha botões
}


// Botão
void executarAcao(int indice) {
  char horaStr[6];

  switch (indice) {
    case 0:
      alarmeEditando = 1;
      tecladoAberto = 0;

      Serial.println(F("CONFIGURAR ALARME 1 PRESSIONADO"));
      definirCicloAlarme(1, 0);
      navigateToScreen(SCREEN_DEFAL1);
      break;
    case 1:
      alarmeEditando = 2;
      tecladoAberto = 0;

      Serial.println(F("CONFIGURAR ALARME 2 PRESSIONADO"));
      definirCicloAlarme(2, 0);

      navigateToScreen(SCREEN_DEFAL2);

      break;
    case 2:
      alarmeEditando = 3;
      tecladoAberto = 0;

      Serial.println(F("CONFIGURAR ALARME 3 PRESSIONADO"));
      definirCicloAlarme(3, 0);

      navigateToScreen(SCREEN_DEFAL3);

      break;
    case 3:
      alarmeEditando = 4;
      tecladoAberto = 0;


      Serial.println(F("CONFIGURAR ALARME 4 PRESSIONADO"));
      definirCicloAlarme(4, 0);
      navigateToScreen(SCREEN_DEFAL4);


      break;
    case 4:
      alarmeEditando = 5;
      tecladoAberto = 0;

      Serial.println(F("CONFIGURAR ALARME 5 PRESSIONADO"));
      definirCicloAlarme(5, 0);
      navigateToScreen(SCREEN_DEFAL5);

      break;
    case 5:
      alarmeEditando = 6;
      tecladoAberto = 0;

      Serial.println(F("CONFIGURAR ALARME 6 PRESSIONADO"));
      definirCicloAlarme(6, 0);
      navigateToScreen(SCREEN_DEFAL6);

      break;
    // --- Alarme 1 ---
    case 6: processarAlarme(1); break;
    case 7: processarAlarme(2); break;
    case 8: processarAlarme(3); break;
    case 9: processarAlarme(4); break;
    case 10: processarAlarme(5); break;
    case 11: processarAlarme(6); break;
    case 12:
      AllReset();
      navigateToScreen(SCREEN_EDITOR);
      break;
    case 13:
      navigateToScreen(SCREEN_EDITOR);
      break;
    case 14:  // ✅ RESET ALARME 1
      salvarAlarme(1, false);
      Serial.println(F("DEFINIR ALARME 1 RESETADO"));
      textosAlarme[0][0] = '\0';
      desbloquearEdicaoAlarme(1);
      deletarAlarme(1);
      definirCicloAlarme(1, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 0, 0);
      Serial3.print(F("resetalarmecomum"));

      navigateToScreen(SCREEN_EDITOR);
      break;

    case 15:  // ❌ NÃO RESETAR ALARME 1
      navigateToScreen(SCREEN_EDITOR);
      break;

    case 16:  // ✅ RESET ALARME 2
      salvarAlarme(2, false);
      Serial.println(F("DEFINIR ALARME 2 RESETADO"));
      textosAlarme[1][0] = '\0';
      desbloquearEdicaoAlarme(2);
      deletarAlarme(2);
      definirCicloAlarme(2, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 1, 0);
      Serial3.print(F("resetalarmecomum"));

      navigateToScreen(SCREEN_EDITOR);
      break;

    case 17:  // ❌ NÃO RESETAR ALARME 2
      navigateToScreen(SCREEN_EDITOR);
      break;

    case 18:  // ✅ RESET ALARME 3
      salvarAlarme(3, false);
      Serial.println(F("DEFINIR ALARME 3 RESETADO"));
      textosAlarme[2][0] = '\0';
      desbloquearEdicaoAlarme(3);
      definirCicloAlarme(3, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 2, 0);
      Serial3.print(F("resetalarmecomum"));

      navigateToScreen(SCREEN_EDITOR);
      deletarAlarme(3);

      break;

    case 19:  // ❌ NÃO RESETAR ALARME 3
      navigateToScreen(SCREEN_EDITOR);
      break;

    case 20:  // ✅ RESET ALARME 4
      salvarAlarme(4, false);
      Serial.println(F("DEFINIR ALARME 4 RESETADO"));
      textosAlarme[3][0] = '\0';
      desbloquearEdicaoAlarme(4);
      deletarAlarme(4);
      definirCicloAlarme(4, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 3, 0);
      Serial3.print(F("resetalarmecomum"));

      navigateToScreen(SCREEN_EDITOR);
      break;

    case 21:  // ❌ NÃO RESETAR ALARME 4
      navigateToScreen(SCREEN_EDITOR);
      break;

    case 22:  // ✅ RESET ALARME 5
      salvarAlarme(5, false);
      Serial.println(F("DEFINIR ALARME 5 RESETADO"));
      textosAlarme[4][0] = '\0';
      desbloquearEdicaoAlarme(5);
      deletarAlarme(5);
      definirCicloAlarme(5, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 4, 0);
      Serial3.print(F("resetalarmecomum"));

      navigateToScreen(SCREEN_EDITOR);
      break;

    case 23:  // ❌ NÃO RESETAR ALARME 5
      navigateToScreen(SCREEN_EDITOR);
      break;

    case 24:  // ✅ RESET ALARME 6
      salvarAlarme(6, false);
      Serial.println(F("DEFINIR ALARME 6 RESETADO"));
      textosAlarme[5][0] = '\0';
      desbloquearEdicaoAlarme(6);
      deletarAlarme(6);
      definirCicloAlarme(6, 0);
      EEPROM.update(ADDR_CICLO_ALARME1 + 5, 0);
      Serial3.print(F("resetalarmecomum"));
      navigateToScreen(SCREEN_EDITOR);
      break;
    case 25:
      navigateToScreen(SCREEN_EDITOR);  // Botão Não
      break;
      // DEFAL1 (55–58) alarme 1
    case 55:
      if (horasAlarme[0] == 0) horasAlarme[0] = 23;
      else horasAlarme[0]--;
      EEPROM.update(ADDR_HORA1, horasAlarme[0]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[0]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[0]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 56:
      horasAlarme[0] = (horasAlarme[0] + 1) % 24;
      EEPROM.update(ADDR_HORA1, horasAlarme[0]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[0]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[0]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 57:
      if (minutosAlarme[0] == 0) minutosAlarme[0] = 59;
      else if (minutosAlarme[0] == 59) minutosAlarme[0] = 50;
      else minutosAlarme[0] -= 10;
      EEPROM.update(ADDR_MIN1, minutosAlarme[0]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[0]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[0]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 58:
      if (minutosAlarme[0] < 50) minutosAlarme[0] += 10;
      else if (minutosAlarme[0] == 50) minutosAlarme[0] = 59;
      else minutosAlarme[0] = 0;
      EEPROM.update(ADDR_MIN1, minutosAlarme[0]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[0]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[0]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;

    // DEFAL2 (59–62)
    case 59:
      if (horasAlarme[1] == 0) horasAlarme[1] = 23;
      else horasAlarme[1]--;
      EEPROM.update(ADDR_HORA2, horasAlarme[1]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[1]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[1]);
      tft.fillRect(71, 176, 39, 38, BLACK);
      tft.setCursor(70, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 60:
      horasAlarme[1] = (horasAlarme[1] + 1) % 24;
      EEPROM.update(ADDR_HORA2, horasAlarme[1]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[1]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[1]);
      tft.fillRect(71, 176, 39, 38, BLACK);
      tft.setCursor(70, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 61:
      if (minutosAlarme[1] == 0) minutosAlarme[1] = 59;
      else if (minutosAlarme[1] == 59) minutosAlarme[1] = 50;
      else minutosAlarme[1] -= 10;
      EEPROM.update(ADDR_MIN2, minutosAlarme[1]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[1]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[1]);
      tft.fillRect(201, 176, 39, 38, BLACK);
      tft.setCursor(200, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 62:
      if (minutosAlarme[1] < 50) minutosAlarme[1] += 10;
      else if (minutosAlarme[1] == 50) minutosAlarme[1] = 59;
      else minutosAlarme[1] = 0;
      EEPROM.update(ADDR_MIN2, minutosAlarme[1]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[1]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[1]);
      tft.fillRect(201, 176, 39, 38, BLACK);
      tft.setCursor(200, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;

    // DEFAL3 (63–66)
    case 63:
      if (horasAlarme[2] == 0) horasAlarme[2] = 23;
      else horasAlarme[2]--;
      EEPROM.update(ADDR_HORA3, horasAlarme[2]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[2]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[2]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 64:
      horasAlarme[2] = (horasAlarme[2] + 1) % 24;
      EEPROM.update(ADDR_HORA3, horasAlarme[2]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[2]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[2]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 205);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 65:
      if (minutosAlarme[2] == 0) minutosAlarme[2] = 59;
      else if (minutosAlarme[2] == 59) minutosAlarme[2] = 50;
      else minutosAlarme[2] -= 10;
      EEPROM.update(ADDR_MIN3, minutosAlarme[2]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[2]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[2]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 66:
      if (minutosAlarme[2] < 50) minutosAlarme[2] += 10;
      else if (minutosAlarme[2] == 50) minutosAlarme[2] = 59;
      else minutosAlarme[2] = 0;
      EEPROM.update(ADDR_MIN3, minutosAlarme[2]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[2]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[2]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;

    // DEFAL4 (67–70)
    case 67:
      if (horasAlarme[3] == 0) horasAlarme[3] = 23;
      else horasAlarme[3]--;
      EEPROM.update(ADDR_HORA4, horasAlarme[3]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[3]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[3]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 68:
      horasAlarme[3] = (horasAlarme[3] + 1) % 24;
      EEPROM.update(ADDR_HORA4, horasAlarme[3]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[3]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[3]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 69:
      if (minutosAlarme[3] == 0) minutosAlarme[3] = 59;
      else if (minutosAlarme[3] == 59) minutosAlarme[3] = 50;
      else minutosAlarme[3] -= 10;
      EEPROM.update(ADDR_MIN4, minutosAlarme[3]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[3]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[3]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 70:
      if (minutosAlarme[3] < 50) minutosAlarme[3] += 10;
      else if (minutosAlarme[3] == 50) minutosAlarme[3] = 59;
      else minutosAlarme[3] = 0;
      EEPROM.update(ADDR_MIN4, minutosAlarme[3]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[3]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[3]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;

    // DEFAL5 (71–74)
    case 71:
      if (horasAlarme[4] == 0) horasAlarme[4] = 23;
      else horasAlarme[4]--;
      EEPROM.update(ADDR_HORA5, horasAlarme[4]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[4]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[4]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 72:
      horasAlarme[4] = (horasAlarme[4] + 1) % 24;
      EEPROM.update(ADDR_HORA5, horasAlarme[4]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[4]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[4]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 73:
      if (minutosAlarme[4] == 0) minutosAlarme[4] = 59;
      else if (minutosAlarme[4] == 59) minutosAlarme[4] = 50;
      else minutosAlarme[4] -= 10;
      EEPROM.update(ADDR_MIN5, minutosAlarme[4]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[4]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[4]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 74:
      if (minutosAlarme[4] < 50) minutosAlarme[4] += 10;
      else if (minutosAlarme[4] == 50) minutosAlarme[4] = 59;
      else minutosAlarme[4] = 0;
      EEPROM.update(ADDR_MIN5, minutosAlarme[4]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[4]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[4]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;

    // DEFAL6 (75–78)
    case 75:
      if (horasAlarme[5] == 0) horasAlarme[5] = 23;
      else horasAlarme[5]--;
      EEPROM.update(ADDR_HORA6, horasAlarme[5]);
      Serial.print(F("Hora diminuída para: "));
      Serial.println(horasAlarme[5]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[5]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 76:
      horasAlarme[5] = (horasAlarme[5] + 1) % 24;
      EEPROM.update(ADDR_HORA6, horasAlarme[5]);
      Serial.print(F("Hora aumentada para: "));
      Serial.println(horasAlarme[5]);
      sprintf_P(horaStr, PSTR("%02d"), horasAlarme[5]);
      tft.fillRect(71, 186, 39, 38, BLACK);
      tft.setCursor(70, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 77:
      if (minutosAlarme[5] == 0) minutosAlarme[5] = 59;
      else if (minutosAlarme[5] == 59) minutosAlarme[5] = 50;
      else minutosAlarme[5] -= 10;
      EEPROM.update(ADDR_MIN6, minutosAlarme[5]);
      Serial.print(F("Minuto diminuído para: "));
      Serial.println(minutosAlarme[5]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[5]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    case 78:
      if (minutosAlarme[5] < 50) minutosAlarme[5] += 10;
      else if (minutosAlarme[5] == 50) minutosAlarme[5] = 59;
      else minutosAlarme[5] = 0;
      EEPROM.update(ADDR_MIN6, minutosAlarme[5]);
      Serial.print(F("Minuto aumentado para: "));
      Serial.println(minutosAlarme[5]);
      sprintf_P(horaStr, PSTR("%02d"), minutosAlarme[5]);
      tft.fillRect(201, 186, 39, 38, BLACK);
      tft.setCursor(200, 215);
      tft.setTextSize(2);
      tft.setTextColor(WHITE);
      tft.print(horaStr);
      break;
    // --- Alarme 1 ---
    case 79:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 79) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;
    case 80:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 80) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;
    case 81:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 81) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;

    // --- Alarme 2 ---
    case 82:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 82) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;

    case 83:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 83) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;

    case 84:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 84) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;

    // --- Alarme 3 ---
    case 85:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 85) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;

    case 86:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 86) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;

    case 87:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 87) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;

    // --- Alarme 4 ---
    case 88:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 88) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;

    case 89:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 89) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;

    case 90:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 90) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;

    // --- Alarme 5 ---
    case 91:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 91) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;

    case 92:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 92) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;

    case 93:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 93) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;

    // --- Alarme 6 ---
    case 94:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 94) {
          Serial.println(F("Ciclo de 6 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 6);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("6"));
        } else {
          Serial.println(F("Ciclo de 6 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(78, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("6"));
        }
      }
      break;

    case 95:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 95) {
          Serial.println(F("Ciclo de 8 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 8);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("8"));
        } else {
          Serial.println(F("Ciclo de 8 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(178, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("8"));
        }
      }
      break;

    case 96:
      {
        int indiceTela = currentScreen - SCREEN_DEFAL1;
        if (ultimoToggleAtivoPorTela[indiceTela] == 96) {
          Serial.println(F("Ciclo de 12 horas ATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 12);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(AZURE);
          tft.print(F("12"));
        } else {
          Serial.println(F("Ciclo de 12 horas DESATIVADO!"));
          definirCicloAlarme(indiceTela + 1, 0);
          tft.setCursor(266, 276);
          tft.setTextSize(2);
          tft.setTextColor(WHITE);
          tft.print(F("12"));
        }
      }
      break;
    case 97:
      {  // 🔼 Botão superior — subir 2 linhas
        if (scrollOffset > 0) {
          scrollOffset -= 2;
          if (scrollOffset < 0)
            scrollOffset = 0;
          drawScrollArea();
          atualizarEstadoScrollBotoes();  // 🔄 atualiza ativação e cores dos botões
          delay(150);
        }
      }
      break;
    case 98:
      {  // 🔽 Botão inferior — descer 2 linhas
        int visibleLines = SCROLL_H / lineHeight;
        if (scrollOffset < totalLinhas - visibleLines) {
          scrollOffset += 2;
          if (scrollOffset > totalLinhas - visibleLines)
            scrollOffset = totalLinhas - visibleLines;
          drawScrollArea();
          atualizarEstadoScrollBotoes();  // 🔄 atualiza ativação e cores dos botões
          delay(150);
        }
      }
      break;
    case 99:
      {
        navigateToScreen(SCREEN_CALIBRACAO);
      }
      break;
    case 100:
      {
        navigateToScreen(SCREEN_INFO1);
      }
      break;
    case 101:
      {
        navigateToScreen(SCREEN_INFO);
      }
      break;
    case 103:
      {
        navigateToScreen(SCREEN_INFO1);
      }
      break;
    // --- DIA ↓ ---
    case 104:
      if (rtcDia > 1) rtcDia--;
      else rtcDia = diasNoMes(rtcMes, rtcAno);
      desenharCamposRTC();
      break;

    // --- DIA ↑ ---
    case 105:
      rtcDia++;
      if (rtcDia > diasNoMes(rtcMes, rtcAno)) rtcDia = 1;
      desenharCamposRTC();
      break;

    // --- MÊS ↓ ---
    case 106:
      if (rtcMes > 1) rtcMes--;
      else rtcMes = 12;
      if (rtcDia > diasNoMes(rtcMes, rtcAno)) rtcDia = diasNoMes(rtcMes, rtcAno);
      desenharCamposRTC();
      break;

    // --- MÊS ↑ ---
    case 107:
      rtcMes++;
      if (rtcMes > 12) rtcMes = 1;
      if (rtcDia > diasNoMes(rtcMes, rtcAno)) rtcDia = diasNoMes(rtcMes, rtcAno);
      desenharCamposRTC();
      break;

    // --- ANO ↓ ---
    case 109:
      if (rtcAno < 2050) {
        rtcAno++;
        // garante que dia seja válido no novo ano (fevereiro bissexto etc.)
        if (rtcDia > diasNoMes(rtcMes, rtcAno)) rtcDia = diasNoMes(rtcMes, rtcAno);
        desenharCamposRTC();
        atualizarEstadoScrollBotoes();  // atualiza travas/cores dos botões
      }
      break;

    // --- ANO aum) ---
    case 108:
      if (rtcAno > 2025) {
        rtcAno--;
        // ajusta dia caso ano novo torne fevereiro menor (ex: 29 -> 28)
        if (rtcDia > diasNoMes(rtcMes, rtcAno)) rtcDia = diasNoMes(rtcMes, rtcAno);
        desenharCamposRTC();
        atualizarEstadoScrollBotoes();  // atualiza travas/cores dos botões
      }
      break;

    // --- HORA ↓ ---
    case 110:
      if (rtcHora == 0) rtcHora = 23;
      else rtcHora--;
      desenharCamposRTC();
      break;

    // --- HORA ↑ ---
    case 111:
      rtcHora = (rtcHora + 1) % 24;
      desenharCamposRTC();
      break;

    // --- MINUTO ↓ ---
    case 112:
      if (rtcMin == 0) rtcMin = 59;
      else rtcMin--;
      desenharCamposRTC();
      break;

    // --- MINUTO ↑ ---
    case 113:
      rtcMin = (rtcMin + 1) % 60;
      desenharCamposRTC();
      break;
    case 114:  //botao de confirmar a edição
      {
        navigateToScreen(SCREEN_HOME);
        salvarCalibracaoRTC();
      }
      break;
    default:
      break;
  }
}
void desenharBotao(Botao btn) {
  uint16_t cor = btn.pressionado ? btn.corPressionado : btn.corNormal;

  // Desenha o botão
  tft.fillRoundRect(btn.x, btn.y, btn.largura, btn.altura, 5, cor);
  tft.drawRoundRect(btn.x, btn.y, btn.largura, btn.altura, 5, WHITE);

  // Texto do botão
  tft.setTextColor(btn.pressionado ? WHITE : BLACK);  // Texto preto quando não pressionado
  tft.setTextSize(1.3);

  int16_t x1, y1;
  uint16_t w, h;
  tft.getTextBounds(btn.texto, 0, 0, &x1, &y1, &w, &h);

  int16_t xTexto = btn.x + (btn.largura - w) / 2;
  int16_t yTexto = btn.y + (btn.altura - h) / 2 + h;

  tft.setCursor(xTexto, yTexto);
  tft.print(btn.texto);
}
void desenharTodosBotoes() {
  for (int i = 0; i < NUM_BOTOES; i++) {
    if (botaoPertenceATela(i)) {
      desenharBotao(botoes[i]);
    }
  }
}

void inicializaBotoes() {
  // Zera todos os botões
  for (int i = 0; i < NUM_BOTOES; i++) {
    botoes[i] = { -1, -1, 0, 0, GREY, DARKGREY, "", false, i, false, false };
    // último "false" = toggle desativado (botão normal)
  }
  if (currentScreen == SCREEN_HOME) {
    botoes[98] = { 445, 213, 15, 80, BLACK, GREY, "", false, 98, false };
    botoes[97] = { 445, 130, 15, 80, BLACK, GREY, "", false, 97, false };
  }
  if (currentScreen == SCREEN_INFO) {
    botoes[99] = { 30, 250, 200, 40, GREY, AZURE, "CALIBRAR HORARIO", false, 99, false, false };
    botoes[100] = { 410, 250, 40, 40, GREY, DARKGREY, ">", false, 100, false, false };
  }
  if (currentScreen == SCREEN_INFO1) {
    botoes[101] = { 30, 250, 40, 40, GREY, DARKGREY, "<", false, 101, false, false };
  }
  if (currentScreen == SCREEN_INFO2) {
    botoes[103] = { 30, 250, 40, 40, GREY, DARKGREY, "<", false, 103, false, false };
  }
  if (currentScreen == SCREEN_CALIBRACAO) {
    //DIA
    botoes[104] = { 30, 145, 40, 40, GREY, DARKGREY, "-", false, 104, false };
    botoes[105] = { 110, 145, 40, 40, GREY, DARKGREY, "+", false, 105, false };
    //MÊS
    botoes[106] = { 160, 145, 40, 40, GREY, DARKGREY, "-", false, 106, false };
    botoes[107] = { 240, 145, 40, 40, GREY, DARKGREY, "+", false, 107, false };
    //ANO
    botoes[108] = { 290, 145, 40, 40, GREY, DARKGREY, "-", false, 108, false };
    botoes[109] = { 410, 145, 40, 40, GREY, DARKGREY, "+", false, 109, false };
    //HORA
    botoes[110] = { 50, 240, 40, 40, GREY, DARKGREY, "-", false, 110, false };
    botoes[111] = { 130, 240, 40, 40, GREY, DARKGREY, "+", false, 111, false };
    //MINUTO
    botoes[112] = { 220, 240, 40, 40, GREY, DARKGREY, "-", false, 112, false };
    botoes[113] = { 300, 240, 40, 40, GREY, DARKGREY, "+", false, 113, false };
    botoes[114] = { 390, 245, 60, 45, AZURE, DARKGREY, "OK", false, 114, false };
  }

  if (currentScreen == SCREEN_EDITOR) {
    int b = 0;
    if (!alarmeAtivo(1))
      botoes[b++] = { 25, 130, 120, 42, GREY, DARKGREY, "DEFINIR", false, 0, false };
    if (!alarmeAtivo(2))
      botoes[b++] = { 180, 130, 120, 42, GREY, DARKGREY, "DEFINIR", false, 1, false };
    if (!alarmeAtivo(3))
      botoes[b++] = { 335, 130, 120, 42, GREY, DARKGREY, "DEFINIR", false, 2, false };
    if (!alarmeAtivo(4))
      botoes[b++] = { 25, 250, 120, 42, GREY, DARKGREY, "DEFINIR", false, 3, false };
    if (!alarmeAtivo(5))
      botoes[b++] = { 180, 250, 120, 42, GREY, DARKGREY, "DEFINIR", false, 4, false };
    if (!alarmeAtivo(6))
      botoes[b++] = { 335, 250, 120, 42, GREY, DARKGREY, "DEFINIR", false, 5, false };
  }

  // botões DEFAL1
  if (currentScreen == SCREEN_DEFAL1) {
    botoes[55] = { 30, 185, 40, 40, GREY, DARKGREY, "-", false, 55, false };
    botoes[56] = { 110, 185, 40, 40, GREY, DARKGREY, "+", false, 56, false };
    botoes[57] = { 160, 185, 40, 40, GREY, DARKGREY, "-", false, 57, false };
    botoes[58] = { 240, 185, 40, 40, GREY, DARKGREY, "+", false, 58, false };
    botoes[79] = { 30, 245, 40, 40, GREY, AZURE, "", false, 79, true };
    botoes[80] = { 130, 245, 40, 40, GREY, AZURE, "", false, 80, true };
    botoes[81] = { 230, 245, 40, 40, GREY, AZURE, "", false, 81, true };
  }

  // botões DEFAL2
  if (currentScreen == SCREEN_DEFAL2) {
    botoes[59] = { 30, 175, 40, 40, GREY, DARKGREY, "-", false, 59, false };
    botoes[60] = { 110, 175, 40, 40, GREY, DARKGREY, "+", false, 60, false };
    botoes[61] = { 160, 175, 40, 40, GREY, DARKGREY, "-", false, 61, false };
    botoes[62] = { 240, 175, 40, 40, GREY, DARKGREY, "+", false, 62, false };
    botoes[82] = { 30, 245, 40, 40, GREY, AZURE, "", false, 82, true };
    botoes[83] = { 130, 245, 40, 40, GREY, AZURE, "", false, 83, true };
    botoes[84] = { 230, 245, 40, 40, GREY, AZURE, "", false, 84, true };
  }

  // botões DEFAL3
  if (currentScreen == SCREEN_DEFAL3) {
    botoes[63] = { 30, 185, 40, 40, GREY, DARKGREY, "-", false, 63, false };
    botoes[64] = { 110, 185, 40, 40, GREY, DARKGREY, "+", false, 64, false };
    botoes[65] = { 160, 185, 40, 40, GREY, DARKGREY, "-", false, 65, false };
    botoes[66] = { 240, 185, 40, 40, GREY, DARKGREY, "+", false, 66, false };
    botoes[85] = { 30, 245, 40, 40, GREY, AZURE, "", false, 85, true };
    botoes[86] = { 130, 245, 40, 40, GREY, AZURE, "", false, 86, true };
    botoes[87] = { 230, 245, 40, 40, GREY, AZURE, "", false, 87, true };
  }

  // botões DEFAL4
  if (currentScreen == SCREEN_DEFAL4) {
    botoes[67] = { 30, 185, 40, 40, GREY, DARKGREY, "-", false, 67, false };
    botoes[68] = { 110, 185, 40, 40, GREY, DARKGREY, "+", false, 68, false };
    botoes[69] = { 160, 185, 40, 40, GREY, DARKGREY, "-", false, 69, false };
    botoes[70] = { 240, 185, 40, 40, GREY, DARKGREY, "+", false, 70, false };
    botoes[88] = { 30, 245, 40, 40, GREY, AZURE, "", false, 88, true };
    botoes[89] = { 130, 245, 40, 40, GREY, AZURE, "", false, 89, true };
    botoes[90] = { 230, 245, 40, 40, GREY, AZURE, "", false, 90, true };
  }

  // botões DEFAL5
  if (currentScreen == SCREEN_DEFAL5) {
    botoes[71] = { 30, 185, 40, 40, GREY, DARKGREY, "-", false, 71, false };
    botoes[72] = { 110, 185, 40, 40, GREY, DARKGREY, "+", false, 72, false };
    botoes[73] = { 160, 185, 40, 40, GREY, DARKGREY, "-", false, 73, false };
    botoes[74] = { 240, 185, 40, 40, GREY, DARKGREY, "+", false, 74, false };
    botoes[91] = { 30, 245, 40, 40, GREY, AZURE, "", false, 91, true };
    botoes[92] = { 130, 245, 40, 40, GREY, AZURE, "", false, 92, true };
    botoes[93] = { 230, 245, 40, 40, GREY, AZURE, "", false, 93, true };
  }

  // botões DEFAL6
  if (currentScreen == SCREEN_DEFAL6) {
    botoes[75] = { 30, 185, 40, 40, GREY, DARKGREY, "-", false, 75, false };
    botoes[76] = { 110, 185, 40, 40, GREY, DARKGREY, "+", false, 76, false };
    botoes[77] = { 160, 185, 40, 40, GREY, DARKGREY, "-", false, 77, false };
    botoes[78] = { 240, 185, 40, 40, GREY, DARKGREY, "+", false, 78, false };
    botoes[94] = { 30, 245, 40, 40, GREY, AZURE, "", false, 94, true };
    botoes[95] = { 130, 245, 40, 40, GREY, AZURE, "", false, 95, true };
    botoes[96] = { 230, 245, 40, 40, GREY, AZURE, "", false, 96, true };
  }

  // botões OK para todos DEFALn
  if (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6) {
    int idx = currentScreen - SCREEN_DEFAL1 + 6;
    botoes[idx] = { 390, 245, 60, 45, GREY, AZURE, "OK", false, idx, false };
  }

  // botoes RESET
  else if (currentScreen == SCREEN_RESETALL) {
    botoes[12] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 12, false };
    botoes[13] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 13, false };
  } else if (currentScreen == SCREEN_RESET1) {
    botoes[14] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 14, false };
    botoes[15] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 15, false };
  } else if (currentScreen == SCREEN_RESET2) {
    botoes[16] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 16, false };
    botoes[17] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 17, false };
  } else if (currentScreen == SCREEN_RESET3) {
    botoes[18] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 18, false };
    botoes[19] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 19, false };
  } else if (currentScreen == SCREEN_RESET4) {
    botoes[20] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 20, false };
    botoes[21] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 21, false };
  } else if (currentScreen == SCREEN_RESET5) {
    botoes[22] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 22, false };
    botoes[23] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 23, false };
  } else if (currentScreen == SCREEN_RESET6) {
    botoes[24] = { 250, 173, 190, 100, GREEN, GREY, "SIM", false, 24, false };
    botoes[25] = { 40, 173, 190, 100, RED, GREY, "NAO", false, 25, false };
  }

  // botoes teclado virtual
  else if (currentScreen == SCREEN_KEYBOARD) {
    int baseIdx = 26;
    float largura = 37.5;
    float altura = 37.5;
    int espaco = 5;

    float totalWidth = (10 * largura) + (9 * espaco);
    int startX = (480 - totalWidth) / 2;
    int startY = 110;

    int linha = 0, coluna = 0;

    for (int i = 0; i < 26; i++) {
      int linhaAtual = linha;
      int xBase = (linhaAtual == 2)
                    ? (480 - ((6 * largura) + (5 * espaco))) / 2
                    : startX;

      botoes[baseIdx + i] = {
        (int)(xBase + coluna * (largura + espaco)),
        (int)(startY + linha * (altura + espaco)),
        (int)largura, (int)altura,
        GREY, DARKGREY,
        letrasTeclado[i],
        false,
        baseIdx + i,
        false
      };

      coluna++;
      if ((linha == 0 || linha == 1) && coluna >= 10) {
        coluna = 0;
        linha++;
      } else if (linha == 2 && coluna >= 6) {
        coluna = 0;
        linha++;
      }
    }

    int larguraEspaco = 100;
    int larguraEnter = 90;
    int larguraDelete = 90;
    int espacoEntre = 10;
    int totalWidthEsp = larguraEspaco + larguraEnter + larguraDelete + 2 * espacoEntre;
    int startXEsp = (480 - totalWidthEsp) / 2;
    int startYEsp = startY + (3 * (altura + espaco)) + 10;

    botoes[52] = { startXEsp, startYEsp, larguraEspaco, 40, GREY, DARKGREY, "ESPACO", false, 52, false };
    botoes[53] = { startXEsp + larguraEspaco + espacoEntre, startYEsp, larguraEnter, 40, GREEN, DARKGREY, "ENTER", false, 53, false };
    botoes[54] = { startXEsp + larguraEspaco + espacoEntre + larguraEnter + espacoEntre, startYEsp, larguraDelete, 40, RED, DARKGREY, "DELETE", false, 54, false };
  }

  // --- Exemplo: transformar um botão em toggle ---
  // botoes[55].toggle = true;   // agora o botão 55 será tipo toggle (pressiona ↔ solta)
}

//Teclado
void processarTecla(const char* tecla) {
  // DELETE
  if (strcmp(tecla, "DELETE") == 0) {
    if (textoDigitado.length() > 0) {
      textoDigitado.remove(textoDigitado.length() - 1);
    }
  }
  // ESPAÇO
  else if (strcmp(tecla, "ESPACO") == 0) {
    textoDigitado += " ";
  }
  // ENTER
  else if (strcmp(tecla, "ENTER") == 0) {
    // trava: só continua se o texto tiver pelo menos 3 caracteres
    if (textoDigitado.length() >= 3 && alarmeEditando >= 1 && alarmeEditando <= 6) {
      int addr;
      switch (alarmeEditando) {
        case 1: addr = ADDR_TEXTO1; break;
        case 2: addr = ADDR_TEXTO2; break;
        case 3: addr = ADDR_TEXTO3; break;
        case 4: addr = ADDR_TEXTO4; break;
        case 5: addr = ADDR_TEXTO5; break;
        case 6: addr = ADDR_TEXTO6; break;
      }

      // salva o texto
      strncpy(textosAlarme[alarmeEditando - 1], textoDigitado.c_str(),
              sizeof(textosAlarme[alarmeEditando - 1]));
      textosAlarme[alarmeEditando - 1][sizeof(textosAlarme[alarmeEditando - 1]) - 1] = '\0';
      EEPROM.put(addr, textosAlarme[alarmeEditando - 1]);
      Serial.println("Texto salvo!");

      textoDigitado = "";


      // volta para tela de origem
      navigateToScreen((AppScreen)telaOrigem);
      currentScreen = (AppScreen)telaOrigem;
      return;
    } else {
      // feedback visual de erro
      Serial.println("Digite pelo menos 3 caracteres antes de ENTER!");
      tft.setTextColor(RED);
      tft.setTextSize(1);
      tft.setCursor(50, 65);
      tft.fillRoundRect(40, 40, 400, 40, 5, BLACK);
      tft.drawRoundRect(40, 40, 400, 40, 5, WHITE);
      tft.print("DIGITE PELO MENOS 3 CARACTERES!");
      delay(2000);
      tft.fillRoundRect(40, 40, 400, 40, 5, BLACK);
      tft.drawRoundRect(40, 40, 400, 40, 5, WHITE);
    }
  }
  // letra normal
  else {
    textoDigitado += tecla;

    // --- Limite de 20 caracteres ---
    if (textoDigitado.length() > 20) {
      char ultima = textoDigitado.charAt(textoDigitado.length() - 1);
      textoDigitado.remove(textoDigitado.length() - 1);

      // aviso visual
      tft.setTextColor(RED);
      tft.setTextSize(1);
      tft.setCursor(50, 65);
      tft.fillRoundRect(40, 40, 400, 40, 5, BLACK);
      tft.drawRoundRect(40, 40, 400, 40, 5, WHITE);
      tft.print("LIMITE DE 20 CARACTERES ATINGIDO!");
      Serial.print("Letra ignorada: ");
      Serial.println(ultima);
      delay(1000);
      tft.fillRoundRect(40, 40, 400, 40, 5, BLACK);
      tft.drawRoundRect(40, 40, 400, 40, 5, WHITE);
    }
  }

  redesenharCampoTexto();
}


void redesenharCampoTexto() {
  // Apaga área do texto
  delay(200);
  tft.fillRoundRect(40, 40, 400, 40, 5, BLACK);
  // Desenha borda opcional
  tft.drawRoundRect(40, 40, 400, 40, 5, WHITE);

  // Escreve texto atual
  tft.setTextColor(WHITE);
  tft.setTextSize(1);
  tft.setCursor(50, 65);
  tft.print(textoDigitado);
}
void keyboard() {
  Serial.println(F("Janela: TECLADO"));
  Serial.print(F("telaOrigem = "));
  Serial.println(telaOrigem);
  tft.fillScreen(WHITE);
  tecladoAberto = 1;
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
}

void lertemperaturaHome() {
  if (currentScreen == SCREEN_HOME) {
    // Lê a temperatura e converte (RTC retorna valor em 1/4 ºC)
    float tempC = RTC.temperature() / 4.0;
    int graus = (int)tempC;

    // Formata a string de temperatura (ex: "22ºC")
    char tempStra[6];
    sprintf_P(tempStra, PSTR("%02d*C"), graus);
    tft.setTextColor(BLACK);
    tft.setTextSize(2);
    // Verifica as faixas de temperatura
    if (graus > 15 && graus < 28) {
      // Temperatura dentro da faixa ideal (15-25ºC)
      // Adicione aqui o código para este caso
      tft.fillRect(17, 15, 140, 55, WHITE);
      tft.setCursor(17.5, 53);
      tft.println(tempStra);
      tft.drawBitmap(103, 25, certo, 36, 36, GREEN);
    } else {
      // Temperatura fora da faixa ideal
      if (graus < 15.00) {
        // Temperatura abaixo de 15ºC
        // Adicione aqui ações para temperatura baixa
        tft.fillRect(17, 15, 140, 55, WHITE);
        tft.setCursor(17.5, 53);
        tft.println(tempStra);
        tft.drawBitmap(103, 15, termometrofrio, 55, 55, CYAN);
      } else {  // graus > 25
                // Temperatura acima de 25ºC
        tft.fillRect(17, 15, 140, 55, WHITE);
        tft.setCursor(17.5, 53);
        tft.println(tempStra);
        tft.drawBitmap(103, 15, termometroquente, 55, 55, RED);
      }
    }
  }
}
void lertemperaturaEditor() {
  if (currentScreen == SCREEN_EDITOR) {
    // Lê a temperatura e converte (RTC retorna valor em 1/4 ºC)
    float tempC = RTC.temperature() / 4.0;
    int graus = (int)tempC;

    // Formata a string de temperatura (ex: "22ºC")
    char tempStra[6];
    sprintf_P(tempStra, PSTR("%02d*C"), graus);
    tft.setTextColor(BLACK);
    tft.setTextSize(2);
    // Verifica as faixas de temperatura
    if (graus > 15 && graus < 25) {
      // Temperatura dentro da faixa ideal (15-25ºC)
      // Adicione aqui o código para este caso
      tft.fillRect(330, 15, 150, 55, WHITE);
      tft.setCursor(380, 53);
      tft.println(tempStra);
      tft.drawBitmap(340, 25, certo, 36, 36, GREEN);
    } else {
      // Temperatura fora da faixa ideal
      if (graus < 15.00) {
        // Temperatura abaixo de 15ºC
        // Adicione aqui ações para temperatura baixa
        tft.fillRect(330, 15, 150, 55, WHITE);
        tft.setCursor(380, 53);
        tft.println(tempStra);
        tft.drawBitmap(330, 15, termometrofrio, 55, 55, CYAN);
      } else {  // graus > 25
                // Temperatura acima de 25ºC
        tft.fillRect(330, 15, 150, 55, WHITE);
        tft.setCursor(380, 53);
        tft.println(tempStra);
        tft.drawBitmap(330, 15, termometroquente, 55, 55, RED);
      }
    }
  }
}
void printDigits(int digits) {
  if (digits < 10) Serial.print('0');
  Serial.print(digits);
}


// --- Módulo RTC atualizado ---
void moduloRTC() {
  while (!Serial)
    ;  // Aguarda a conexão serial
  tft.setTextColor(BLUE);
  tft.setCursor(0, 15);
  tft.print(F("1/1    Iniciando configuração do Relogio"));
  Serial.println(F("Iniciando configuração do RTC..."));

  // --- Inicializa comunicação I2C e RTC ---
  Wire.begin();
  RTC.begin();

  // --- Verifica comunicação com o RTC ---
  uint8_t controlReg;
  Wire.beginTransmission(0x68);
  Wire.write(0x0E);
  if (Wire.endTransmission() != 0) {
    tft.setTextColor(RED);
    tft.setCursor(0, 30);
    tft.print(F("1/1    Erro: RTC não encontrado!"));
    Serial.println(F("Erro: RTC não encontrado!"));
    while (1)
      ;  // trava, RTC ausente
  }

  Wire.requestFrom(0x68, 1);
  controlReg = Wire.read();
  tft.setTextColor(GREEN);
  tft.setCursor(0, 30);
  tft.print(F("1/1    Relogio encontrado e funcionando!"));
  Serial.println(F("RTC encontrado e funcionando!"));

  // --- Corrige dia caso esteja acima do máximo do mês ---
  if (rtcDia > diasNoMes(rtcMes, rtcAno)) {
    rtcDia = diasNoMes(rtcMes, rtcAno);
  }

  // --- Verifica se o oscilador parou ---
  if (RTC.oscStopped()) {
    Serial.println(F("Aviso: Oscilador do RTC parou! Horário desincronizado."));
    tft.setTextColor(RED);
    tft.setCursor(0, 45);
    tft.print(F("1/1    Conexao RTC perdida!"));
    tft.setCursor(0, 60);
    tft.print(F("1/1    Horario desincronizado."));
    tft.setCursor(0, 75);
    tft.setTextColor(GREEN);
    tft.print(F("1/1    Calibre o horario atual!"));
    rtcCalibrado = false;
    Serial.println(F("⚠️ RTC descalibrado — alarmes bloqueados!"));

    // 🧹 Limpa o bit OSF (Oscillator Stop Flag) manualmente no registrador 0x0F
    Wire.beginTransmission(0x68);
    Wire.write(0x0F);  // endereço do Status Register
    Wire.endTransmission();
    Wire.requestFrom(0x68, 1);
    uint8_t status = Wire.read();

    status &= ~(1 << 7);  // limpa o bit 7 (OSF)
    Wire.beginTransmission(0x68);
    Wire.write(0x0F);
    Wire.write(status);
    Wire.endTransmission();

    Serial.println(F("🧹 Flag OSF do RTC limpa manualmente."));
  } else {
    tft.setTextColor(BLUE);
    tft.setCursor(0, 45);
    tft.print(F("1/1    Relogio mantem horario valido."));
    Serial.println(F("Relógio mantém horário válido."));
    rtcCalibrado = true;  // ✅ agora marcamos como calibrado
    Serial.println(F("✅ RTC calibrado — alarmes liberados!"));
  }

  // --- Configura saída 1Hz ---
  RTC.squareWave(DS3232RTC::SQWAVE_1_HZ);

  // --- Exibe status final (com leitura direta do RTC) ---
  tmElements_t tm;
  RTC.read(tm);  // Lê data/hora reais do RTC

  char buffer[40];
  sprintf(buffer, "1/1    Data atual: %02d/%02d/%02d %02d:%02d",
          tm.Day, tm.Month, (tmYearToCalendar(tm.Year) % 100), tm.Hour, tm.Minute);

  tft.setTextColor(GREEN);
  tft.setCursor(0, 60);
  tft.print(buffer);
  Serial.println(buffer);
}


void verificarStatusRTC() {
  // tenta ler o horário
  time_t t = RTC.get();

  // ds3231 retorna 0 ou valores inválidos quando falha
  // mas PRINCIPALMENTE: podemos verificar o Wire/I2C

  Wire.beginTransmission(0x68);  // endereço DS3231
  byte erro = Wire.endTransmission();

  if (erro != 0) {
    // RTC desconectado ou I2C travado
    rtcCalibrado = false;
    rtcDisponivel = false;
    return;
  }

  // Se chegou aqui, o RTC está presente no barramento
  rtcDisponivel = true;

  // Agora verifica se oscilador está ok
  if (RTC.oscStopped()) {
    rtcCalibrado = false;
  } else {
    rtcCalibrado = true;
  }
}
void drawClockMarkers(int centerX, int centerY, int radius) {
  // 1. Obtém o tempo atual do RTC
  time_t now = RTC.get();
  int hours = hour(now);
  int minutes = minute(now);

  // 2. Desenha o círculo intermediário (85% do raio)
  int middleCircleRadius = radius * 0.85;
  tft.drawCircle(centerX, centerY, middleCircleRadius, BLACK);

  // 3. Desenha as marcações do relógio
  float angle;
  int innerRadius = radius * 0.9;
  int outerRadius = radius * 0.95;

  for (int i = 0; i < 60; i++) {
    angle = i * 6 * PI / 180 - PI / 2;  // Subtrai PI/2 para começar no topo (12h)

    if (i % 5 == 0) {
      tft.drawLine(
        centerX + (outerRadius * cos(angle)),
        centerY + (outerRadius * sin(angle)),
        centerX + (middleCircleRadius * cos(angle)),
        centerY + (middleCircleRadius * sin(angle)),
        BLACK);
    } else {
      tft.drawLine(
        centerX + (innerRadius * cos(angle)),
        centerY + (innerRadius * sin(angle)),
        centerX + (middleCircleRadius * cos(angle)),
        centerY + (middleCircleRadius * sin(angle)),
        BLACK);
    }
  }

  // 4. Cálculo PRECISO dos ângulos (corrigido)
  float hourAngle = ((hours % 12) * 30.0 + (minutes / 2.0)) * PI / 180.0 - PI / 2;
  float minuteAngle = minutes * 6 * PI / 180.0 - PI / 2;

  // 5. Ponteiro das horas (mais curto)
  tft.drawLine(
    centerX,
    centerY,
    centerX + (middleCircleRadius * 0.6 * cos(hourAngle)),
    centerY + (middleCircleRadius * 0.6 * sin(hourAngle)),
    RED);

  // 6. Ponteiro dos minutos (mais longo)
  tft.drawLine(
    centerX,
    centerY,
    centerX + (middleCircleRadius * 0.85 * cos(minuteAngle)),
    centerY + (middleCircleRadius * 0.85 * sin(minuteAngle)),
    BLUE);
}

//Setup
void inicializacao() {
  moduloRTC();
  for (int i = 0; i < 6; i++) {
    ultimoToggleAtivoPorTela[i] = -1;
  }
  tft.drawRGBBitmap(140, 115, logo, 60, 60);
  tft.drawBitmap(207, 134, Synapse, 90, 20, AZURE);
  tft.setTextColor(RED);
  tft.setTextSize(1.5);
  tft.setCursor(220, 170);
  tft.println(F("Iniciando."));
  retangulo();
  tft.setTextSize(1.5);
  tft.setCursor(220, 170);
  tft.println(F("Iniciando.."));
  retangulo();
  tft.setTextSize(1.5);
  tft.setCursor(220, 170);
  tft.println(F("Iniciando..."));
  delay(500);
}
void retangulo() {
  delay(450);
  tft.fillRect(330, 160, 40, 40, WHITE);
  delay(50);
}


//Telas
void Home() {
  Serial.println(F("Janela: Home"));
  tft.fillScreen(WHITE);
  inicializaBotoes();
  touchEmProgresso = false;
  resetarScroll();
  float squareX = 15;
  float squareY = 86.75;
  float squareSize = 218.25;
  float tempC = RTC.temperature() / 4.0;
  int graus = (int)tempC;

  // Formata a string de temperatura (ex: "22ºC")
  char tempStra[6];
  sprintf_P(tempStra, PSTR("%02d*C"), graus);
  // Cálculo do centro e raio
  float centerX = squareX + squareSize / 2;
  float centerY = squareY + squareSize / 2;
  float radius = (squareSize / 2) - 5;
  tft.drawRGBBitmap(160, 10, logo, 60, 60);
  tft.drawBitmap(227, 29, Synapse, 90, 20, AZURE);
  tft.fillRect(417, 10, 472, 65, WHITE);
  tft.drawBitmap(410, 15, editor, 55, 55, BLACK);
  tft.drawBitmap(345, 15, info, 55, 55, BLACK);
  tft.drawRoundRect(247.5, 86.75, 218.25, 218.25, 10, BLACK);
  tft.drawBitmap(255.25, 91.75, alarmesfuturos, 204, 27, AZURE);
  atualizarAlarmesHome();
  atualizarEstadoScrollBotoes();
  ultimoMinutoAtualizado = minute(RTC.get());
  desenharBotao(botoes[98]);
  desenharBotao(botoes[97]);
  tft.drawRoundRect(squareX, squareY, squareSize, squareSize, 10, BLACK);
  tft.fillRoundRect(16, 87.75, 216.25, 216.25, 10, GREY);
  tft.fillCircle(centerX, centerY, radius, WHITE);
  tft.drawCircle(centerX, centerY, (radius) + 1, BLACK);
  drawClockMarkers(centerX, centerY, radius);
  tft.fillRect(17, 17, 140, 56, WHITE);
  tft.fillCircle(35, 105, 13, DARKGREY);
  tft.drawCircle(35, 105, 14, WHITE);
  // ===== Superior esquerdo (35,105) =====
  tft.fillCircle(35, 105, 13, DARKGREY);
  tft.drawCircle(35, 105, 14, WHITE);

  const int cx_sup_esq = 35;
  const int cy_sup_esq = 105;
  const int tamanho_sup_esq = 6;  // metade do comprimento do X
  // simulação de espessura 1.5 -> offsets -1 e 0
  for (int offs_sup_esq = -1; offs_sup_esq <= 0; offs_sup_esq++) {
    // diagonal ↘
    tft.drawLine(cx_sup_esq - tamanho_sup_esq + offs_sup_esq, cy_sup_esq - tamanho_sup_esq,
                 cx_sup_esq + tamanho_sup_esq + offs_sup_esq, cy_sup_esq + tamanho_sup_esq, WHITE);
    // diagonal ↙
    tft.drawLine(cx_sup_esq - tamanho_sup_esq + offs_sup_esq, cy_sup_esq + tamanho_sup_esq,
                 cx_sup_esq + tamanho_sup_esq + offs_sup_esq, cy_sup_esq - tamanho_sup_esq, WHITE);
  }

  // ===== Superior direito (212,105) - círculo faltante =====
  tft.fillCircle(212, 105, 13, DARKGREY);
  tft.drawCircle(212, 105, 14, WHITE);

  const int cx_sup_dir = 212;
  const int cy_sup_dir = 105;
  const int tamanho_sup_dir = 6;
  for (int offs_sup_dir = -1; offs_sup_dir <= 0; offs_sup_dir++) {
    tft.drawLine(cx_sup_dir - tamanho_sup_dir + offs_sup_dir, cy_sup_dir - tamanho_sup_dir,
                 cx_sup_dir + tamanho_sup_dir + offs_sup_dir, cy_sup_dir + tamanho_sup_dir, WHITE);
    tft.drawLine(cx_sup_dir - tamanho_sup_dir + offs_sup_dir, cy_sup_dir + tamanho_sup_dir,
                 cx_sup_dir + tamanho_sup_dir + offs_sup_dir, cy_sup_dir - tamanho_sup_dir, WHITE);
  }

  // ===== Inferior esquerdo (35,282) =====
  tft.fillCircle(35, 282, 13, DARKGREY);
  tft.drawCircle(35, 282, 14, WHITE);

  const int cx_inf_esq = 35;
  const int cy_inf_esq = 282;
  const int tamanho_inf_esq = 6;
  for (int offs_inf_esq = -1; offs_inf_esq <= 0; offs_inf_esq++) {
    tft.drawLine(cx_inf_esq - tamanho_inf_esq + offs_inf_esq, cy_inf_esq - tamanho_inf_esq,
                 cx_inf_esq + tamanho_inf_esq + offs_inf_esq, cy_inf_esq + tamanho_inf_esq, WHITE);
    tft.drawLine(cx_inf_esq - tamanho_inf_esq + offs_inf_esq, cy_inf_esq + tamanho_inf_esq,
                 cx_inf_esq + tamanho_inf_esq + offs_inf_esq, cy_inf_esq - tamanho_inf_esq, WHITE);
  }

  // ===== Inferior direito (212,282) =====
  tft.fillCircle(212, 282, 13, DARKGREY);
  tft.drawCircle(212, 282, 14, WHITE);

  const int cx_inf_dir = 212;
  const int cy_inf_dir = 282;
  const int tamanho_inf_dir = 6;
  for (int offs_inf_dir = -1; offs_inf_dir <= 0; offs_inf_dir++) {
    tft.drawLine(cx_inf_dir - tamanho_inf_dir + offs_inf_dir, cy_inf_dir - tamanho_inf_dir,
                 cx_inf_dir + tamanho_inf_dir + offs_inf_dir, cy_inf_dir + tamanho_inf_dir, WHITE);
    tft.drawLine(cx_inf_dir - tamanho_inf_dir + offs_inf_dir, cy_inf_dir + tamanho_inf_dir,
                 cx_inf_dir + tamanho_inf_dir + offs_inf_dir, cy_inf_dir - tamanho_inf_dir, WHITE);
  }

  lertemperaturaHome();
}
void Editor() {
  Serial.println(F("Janela: Editor"));
  // Temperatura
  float tempC = RTC.temperature() / 4.0;
  int graus = (int)tempC;
  char tempStra[6];
  sprintf_P(tempStra, PSTR("%02d*C"), graus);

  // Layout superior
  tft.fillScreen(WHITE);
  tft.drawRGBBitmap(160, 10, logo, 60, 60);
  tft.drawBitmap(227, 29, Synapse, 90, 20, AZURE);
  tft.drawBitmap(15, 15, casa, 55, 55, BLACK);
  tft.drawRGBBitmap(80, 25, reset, 30, 30);

  tft.fillRect(345, 15, 150, 55, WHITE);
  tft.setCursor(380, 53);
  tft.setTextColor(BLACK);
  tft.setTextSize(2);
  tft.println(tempStra);
  tft.drawBitmap(340, 25, certo, 36, 36, GREEN);

  // Retângulos principais
  const float startX = 15, endX = 465, startY = 86.75, endY = 305;
  const int cols = 3, rows = 2;
  float totalWidth = endX - startX;
  float totalHeight = endY - startY;
  float spacing = 15;
  float rectWidth = (totalWidth - (cols - 1) * spacing) / cols;
  float rectHeight = (totalHeight - (rows - 1) * spacing) / rows;

  for (int row = 0; row < rows; row++) {
    for (int col = 0; col < cols; col++) {
      float x = startX + col * (rectWidth + spacing);
      float y = startY + row * (rectHeight + spacing);
      if (col == cols - 1) rectWidth = endX - x;
      if (row == rows - 1) rectHeight = endY - y;
      tft.drawRoundRect(x, y, rectWidth, rectHeight, 5, BLACK);
    }
  }

  // Parâmetros fixos dos alarmes
  struct AlarmeInfo {
    int id;
    int x, y;
    const uint16_t corTexto;
    uint16_t corLed;
    const uint16_t* imagem;
  } alarmes[] = {
    { 1, 20, 90, WHITE, RED, lixeira },
    { 2, 175, 90, WHITE, BEIGE, lixeira },
    { 3, 330, 90, WHITE, MAGENTA, lixeira },
    { 4, 20, 208, WHITE, ORANGE, lixeira },
    { 5, 175, 208, BLACK, GREEN, lixeira },
    { 6, 330, 208, BLACK, BLUE, lixeira },
  };
  for (AlarmeInfo alarme : alarmes) {
    if (alarmeAtivo(alarme.id)) {
      tft.fillRoundRect(alarme.x, alarme.y, 100, 62, 5, BLACK);
      tft.fillRoundRect(alarme.x, alarme.y + 30, 130, 62, 5, BLACK);

      if (alarme.id == 5 || alarme.id == 6) {
        tft.fillRoundRect(alarme.x + 2, alarme.y + 5, 72, 20, 5, WHITE);
        tft.setTextColor(BLACK);
      } else {
        tft.setTextColor(alarme.corTexto);
      }

      tft.drawRGBBitmap(alarme.x + 105, alarme.y, alarme.imagem, 25, 25);
      tft.setTextSize(1.9);
      tft.setCursor(alarme.x + 5, alarme.y + 20);
      tft.print(F("Alarme"));
      tft.print(alarme.id);

      tft.fillCircle(alarme.x + 86.5, alarme.y + 15, 10, alarme.corLed);
      tft.drawCircle(alarme.x + 86.5, alarme.y + 15, 11, WHITE);

      // ➕ Mostra o texto salvo limitado a 10 caracteres
      tft.setTextSize(1);
      tft.setTextColor(BLACK);
      int index = alarme.id - 1;
      String textoExibido = limitarTexto(textosAlarme[index], 7);

      // === Fundo do texto ===
      int16_t x1, y1;
      uint16_t w, h;

      // Mede o texto principal
      tft.getTextBounds(textoExibido, alarme.x + 6, alarme.y + 50, &x1, &y1, &w, &h);
      tft.fillRoundRect(x1 - 4, y1 - 4, w + 8, h + 8, 3, GREY);  // padding aumentado

      // Escreve o texto por cima do fundo
      tft.setCursor(alarme.x + 6, alarme.y + 50);
      tft.print(textoExibido);

      // === Horário abaixo ===
      char horarioStr[6];
      sprintf_P(horarioStr, PSTR("%02d:%02d"), horasAlarme[index], minutosAlarme[index]);

      // Mede e desenha fundo do horário
      tft.getTextBounds(horarioStr, alarme.x + 6, alarme.y + 80, &x1, &y1, &w, &h);
      tft.fillRoundRect(x1 - 4, y1 - 4, w + 8, h + 8, 3, GREY);  // padding aumentado

      // Escreve o horário
      tft.setCursor(alarme.x + 6, alarme.y + 80);
      tft.print(horarioStr);

      // === Ciclo do alarme (ex: "6H", "8H", "12H") ===
      if (alarmeAtivo(alarme.id)) {
        String cicloStr = obterTextoCiclo(alarme.id);
        if (cicloStr.length() > 0) {
          int cx = alarme.x + 70;
          int cy = alarme.y + 80;

          // Mede e desenha fundo do ciclo
          tft.getTextBounds(cicloStr, cx, cy, &x1, &y1, &w, &h);
          tft.fillRoundRect(x1 - 4, y1 - 4, w + 8, h + 8, 3, GREY);  // padding aumentado

          // Escreve o texto do ciclo
          tft.setCursor(cx, cy);
          tft.print(cicloStr);
        }
      }
    } else {
      // Parte superior
      tft.fillRoundRect(alarme.x, alarme.y, 130, 62, 5, BLACK);

      // texto do botão
      const char* texto =
        alarme.id == 1 ? "Alarme1" : alarme.id == 2 ? "Alarme2"
                                   : alarme.id == 3 ? "Alarme3"
                                   : alarme.id == 4 ? "Alarme4"
                                   : alarme.id == 5 ? "Alarme5"
                                   : alarme.id == 6 ? "Alarme6"
                                                    : "Alarme?";

      tft.setTextSize(1.9);  // separado, não dentro do ternário

      // calcula centralização
      int16_t x1, y1;
      uint16_t w, h;
      tft.getTextBounds(texto, 0, 0, &x1, &y1, &w, &h);
      int tx = alarme.x + (100 - w) / 2;
      int ty = alarme.y + 20;

      // Parte inferior + ajuste para alarmes 5 e 6
      if (alarme.id == 5 || alarme.id == 6) {
        tft.fillRoundRect(alarme.x, alarme.y + 30, 130, 62, 5, BLACK);
        tft.fillRoundRect(tx - 2, alarme.y + 5, w + 4, 20, 5, WHITE);
        tft.setTextColor(BLACK);
      } else {
        tft.fillRoundRect(alarme.x, alarme.y + 30, 130, 62, 5, BLACK);
        tft.setTextColor(WHITE);
      }

      // Texto centralizado
      tft.setCursor(tx, ty);
      tft.println(texto);

      // Círculo 5px à esquerda
      tft.fillCircle(alarme.x + 102, alarme.y + 15, 10, alarme.corLed);
      tft.drawCircle(alarme.x + 102, alarme.y + 15, 11, WHITE);
    }
  }
}



void ConfigAlarme1() {
  Serial.println(F("Janela: Configuração do Alarme 1"));

  // --- Mantém hora/minuto se veio do teclado, ou zera se não ---
  if (tecladoAberto == 0) {
    // Opcional: zerar apenas se quiser realmente resetar
    horasAlarme[0] = 0;
    minutosAlarme[0] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 1 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 1 (voltou do teclado)"));
  }

  // --- Desenho da tela ---
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 210);
  tft.drawRoundRect(30, 185, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 185, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 175);
  tft.print(F("HORA"));
  tft.setCursor(185, 175);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 1"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  tft.print(strlen(textosAlarme[0]) > 0 ? textosAlarme[0] : exemplo1);
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);
  desenharBotao(botoes[55]);
  desenharBotao(botoes[56]);
  desenharBotao(botoes[57]);
  desenharBotao(botoes[58]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  // --- Lê ciclo do EEPROM ---
  int ciclo = EEPROM.read(ADDR_CICLO_ALARME1);
  Serial.print(F("Ciclo atual do alarme 1: "));
  Serial.println(ciclo);

  // --- Define o índice do toggle correto ---
  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 79;
  else if (ciclo == 8) alvoIndice = 80;
  else if (ciclo == 12) alvoIndice = 81;

  // --- Desativa todos os toggles que não correspondem ---
  for (int i = 79; i <= 81; i++) {
    if (i != alvoIndice) definirBotaoTogglePressionado(i, false);
  }

  // --- Ativa o toggle correspondente apenas se válido ---
  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → mantém o toggle anterior"));
  }

  // --- Atualiza texto visual dos ciclos ---
  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    tft.setTextColor(ciclo == ciclos[i] ? AZURE : WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }

  // --- Mostra hora e minuto ---
  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[0]);
  tft.setCursor(70, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[0]);
  tft.setCursor(200, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}


void ConfigAlarme2() {
  Serial.println(F("Janela: Configuração do Alarme 2"));
  if (tecladoAberto == 0) {
    horasAlarme[1] = 0;
    minutosAlarme[1] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 2 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 2 (voltou do teclado)"));
  }

  // 🖥️ Desenho da tela
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 200);
  tft.drawRoundRect(30, 175, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 175, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 168);
  tft.print(F("HORA"));
  tft.setCursor(185, 168);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 2"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  if (strlen(textosAlarme[1]) > 0) {
    tft.print(textosAlarme[1]);
  } else {
    tft.print(exemplo2);
  }
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);
  desenharBotao(botoes[59]);
  desenharBotao(botoes[60]);
  desenharBotao(botoes[61]);
  desenharBotao(botoes[62]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  int ciclo = EEPROM.read(ADDR_CICLO_ALARME2);
  Serial.print(F("Ciclo atual do alarme 2: "));
  Serial.println(ciclo);

  // 🔍 Seleciona o índice alvo
  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 82;
  else if (ciclo == 8) alvoIndice = 83;
  else if (ciclo == 12) alvoIndice = 84;

  // Desativa todos antes
  definirBotaoTogglePressionado(82, false);
  definirBotaoTogglePressionado(83, false);
  definirBotaoTogglePressionado(84, false);

  // Ativa o correspondente
  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → todos os toggles desativados"));
  }

  // Atualiza texto visual
  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    if (ciclo == ciclos[i]) tft.setTextColor(AZURE);
    else tft.setTextColor(WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }

  // Mostra hora/minuto
  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[1]);
  tft.setCursor(70, 205);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[1]);
  tft.setCursor(200, 205);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}

void ConfigAlarme3() {
  Serial.println(F("Janela: Configuração do Alarme 3"));
  if (tecladoAberto == 0) {
    horasAlarme[2] = 0;
    minutosAlarme[2] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 3 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 3 (voltou do teclado)"));
  }

  // 🖥️ Desenho da tela (mantive seu layout)
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 210);
  tft.drawRoundRect(30, 185, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 185, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 175);
  tft.print(F("HORA"));
  tft.setCursor(185, 175);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 3"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  if (strlen(textosAlarme[2]) > 0) tft.print(textosAlarme[2]);
  else tft.print(exemplo3);
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);

  // botoes
  desenharBotao(botoes[63]);
  desenharBotao(botoes[64]);
  desenharBotao(botoes[65]);
  desenharBotao(botoes[66]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  int ciclo = EEPROM.read(ADDR_CICLO_ALARME3);
  Serial.print(F("Ciclo atual do alarme 3: "));
  Serial.println(ciclo);

  // mapeamento: 6->85, 8->86, 12->87
  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 85;
  else if (ciclo == 8) alvoIndice = 86;
  else if (ciclo == 12) alvoIndice = 87;

  // Desativa todos antes
  definirBotaoTogglePressionado(85, false);
  definirBotaoTogglePressionado(86, false);
  definirBotaoTogglePressionado(87, false);

  // Ativa o correspondente (se houver)
  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → todos os toggles desativados"));
  }

  // Atualiza texto visual (6,8,12)
  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    tft.setTextColor((ciclo == ciclos[i]) ? AZURE : WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }
  tft.setTextColor(WHITE);

  // Mostra hora/minuto (posições conforme seu código original)
  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[2]);
  tft.setCursor(70, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[2]);
  tft.setCursor(200, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}

void ConfigAlarme4() {
  Serial.println(F("Janela: Configuração do Alarme 4"));
  if (tecladoAberto == 0) {
    horasAlarme[3] = 0;
    minutosAlarme[3] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 4 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 4 (voltou do teclado)"));
  }

  // 🖥️ Desenho da tela
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 210);
  tft.drawRoundRect(30, 185, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 185, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 175);
  tft.print(F("HORA"));
  tft.setCursor(185, 175);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 4"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  if (strlen(textosAlarme[3]) > 0) {
    tft.print(textosAlarme[3]);
  } else {
    tft.print(exemplo4);
  }
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);
  desenharBotao(botoes[67]);
  desenharBotao(botoes[68]);
  desenharBotao(botoes[69]);
  desenharBotao(botoes[70]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  int ciclo = EEPROM.read(ADDR_CICLO_ALARME4);
  Serial.print(F("Ciclo atual do alarme 4: "));
  Serial.println(ciclo);

  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 88;
  else if (ciclo == 8) alvoIndice = 89;
  else if (ciclo == 12) alvoIndice = 90;

  definirBotaoTogglePressionado(88, false);
  definirBotaoTogglePressionado(89, false);
  definirBotaoTogglePressionado(90, false);

  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → todos os toggles desativados"));
  }

  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    if (ciclo == ciclos[i]) tft.setTextColor(AZURE);
    else tft.setTextColor(WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }

  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[3]);
  tft.setCursor(70, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[3]);
  tft.setCursor(200, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}

void ConfigAlarme5() {
  Serial.println(F("Janela: Configuração do Alarme 5"));
  if (tecladoAberto == 0) {
    horasAlarme[4] = 0;
    minutosAlarme[4] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 5 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 5 (voltou do teclado)"));
  }

  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 210);
  tft.drawRoundRect(30, 185, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 185, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 175);
  tft.print(F("HORA"));
  tft.setCursor(185, 175);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 5"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  if (strlen(textosAlarme[4]) > 0) tft.print(textosAlarme[4]);
  else tft.print(exemplo5);
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);

  // botoes
  desenharBotao(botoes[71]);
  desenharBotao(botoes[72]);
  desenharBotao(botoes[73]);
  desenharBotao(botoes[74]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  int ciclo = EEPROM.read(ADDR_CICLO_ALARME5);
  Serial.print(F("Ciclo atual do alarme 5: "));
  Serial.println(ciclo);

  // mapeamento: 6->91, 8->92, 12->93
  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 91;
  else if (ciclo == 8) alvoIndice = 92;
  else if (ciclo == 12) alvoIndice = 93;

  // Desativa todos antes
  definirBotaoTogglePressionado(91, false);
  definirBotaoTogglePressionado(92, false);
  definirBotaoTogglePressionado(93, false);

  // Ativa o correspondente (se houver)
  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → todos os toggles desativados"));
  }

  // Atualiza texto visual
  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    tft.setTextColor((ciclo == ciclos[i]) ? AZURE : WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }
  tft.setTextColor(WHITE);

  // Hora/minuto
  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[4]);
  tft.setCursor(70, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[4]);
  tft.setCursor(200, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}

void ConfigAlarme6() {
  Serial.println(F("Janela: Configuração do Alarme 6"));
  if (tecladoAberto == 0) {
    horasAlarme[5] = 0;
    minutosAlarme[5] = 0;
    Serial.println(F("Resetando hora e minuto do Alarme 6 para 00:00 (não veio do teclado)"));
  } else {
    Serial.println(F("Mantendo hora e minuto do Alarme 6 (voltou do teclado)"));
  }

  // 🖥️ Desenho da tela
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.drawRGBBitmap(397, 23, logofundobranco, 60, 60);
  tft.setCursor(153, 210);
  tft.drawRoundRect(30, 185, 120, 40, 5, WHITE);
  tft.drawRoundRect(160, 185, 120, 40, 5, WHITE);
  tft.print(F(":"));
  tft.setTextSize(1);
  tft.setCursor(60, 175);
  tft.print(F("HORA"));
  tft.setCursor(185, 175);
  tft.print(F("MINUTO"));
  tft.setCursor(175, 50);
  tft.print(F("CONFIGURAR"));
  tft.setCursor(195, 75);
  tft.print(F("ALARME 6"));
  tft.drawRoundRect(30, 105, 350, 40, 5, WHITE);
  tft.setCursor(35, 130);
  if (strlen(textosAlarme[5]) > 0) tft.print(textosAlarme[5]);
  else tft.print(exemplo6);
  tft.drawRGBBitmap(385, 105, lapis, 40, 40);

  // botoes
  desenharBotao(botoes[75]);
  desenharBotao(botoes[76]);
  desenharBotao(botoes[77]);
  desenharBotao(botoes[78]);
  atualizarEstadoScrollBotoes();

  tft.setCursor(32, 237);
  tft.print(F("CICLO DO ALARME (EM HORAS)"));
  tft.drawRoundRect(30, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(130, 245, 80, 40, 5, WHITE);
  tft.drawRoundRect(230, 245, 80, 40, 5, WHITE);

  int ciclo = EEPROM.read(ADDR_CICLO_ALARME6);
  Serial.print(F("Ciclo atual do alarme 6: "));
  Serial.println(ciclo);

  // mapeamento: 6->94, 8->95, 12->96
  int alvoIndice = -1;
  if (ciclo == 6) alvoIndice = 94;
  else if (ciclo == 8) alvoIndice = 95;
  else if (ciclo == 12) alvoIndice = 96;

  // Desativa todos antes
  definirBotaoTogglePressionado(94, false);
  definirBotaoTogglePressionado(95, false);
  definirBotaoTogglePressionado(96, false);

  // Ativa o correspondente (se houver)
  if (alvoIndice != -1) {
    definirBotaoTogglePressionado(alvoIndice, true);
    Serial.print(F("Botão "));
    Serial.print(alvoIndice);
    Serial.println(F(" ativado automaticamente"));
  } else {
    Serial.println(F("Nenhum ciclo definido → todos os toggles desativados"));
  }

  // Atualiza texto visual
  tft.setTextSize(2);
  int posX[] = { 78, 178, 266 };
  int ciclos[] = { 6, 8, 12 };
  for (int i = 0; i < 3; i++) {
    tft.setTextColor((ciclo == ciclos[i]) ? AZURE : WHITE);
    tft.setCursor(posX[i], 276);
    tft.print(ciclos[i]);
  }
  tft.setTextColor(WHITE);

  // Hora/minuto
  char horaStr[3];
  sprintf_P(horaStr, PSTR("%02d"), horasAlarme[5]);
  tft.setCursor(70, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(horaStr);

  char minStr[3];
  sprintf_P(minStr, PSTR("%02d"), minutosAlarme[5]);
  tft.setCursor(200, 215);
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.print(minStr);
}




//Reset dos alarmes
void escreverTextoCentroSeguro(const String& txt, int deslocX = 0, int deslocY = 0) {
  int16_t caixaX, caixaY;
  uint16_t larguraTxt, alturaTxt;

  tft.setTextSize(2);  // Ajuste se necessário
  tft.getTextBounds(txt, 0, 0, &caixaX, &caixaY, &larguraTxt, &alturaTxt);

  int posX = (480 - larguraTxt) / 2 + deslocX;
  int posY = (320 - alturaTxt) / 2 + alturaTxt + deslocY;

  tft.setCursor(posX, posY);
  tft.print(txt);
}
void escreverTextoCentroSeguro1(const String& txt, int deslocX = 0, int deslocY = 0) {
  int16_t caixaX, caixaY;
  uint16_t larguraTxt, alturaTxt;

  tft.setTextSize(1);  // Ajuste se necessário
  tft.getTextBounds(txt, 0, 0, &caixaX, &caixaY, &larguraTxt, &alturaTxt);

  int posX = (480 - larguraTxt) / 2 + deslocX;
  int posY = (320 - alturaTxt) / 2 + alturaTxt + deslocY;

  tft.setCursor(posX, posY);
  tft.print(txt);
}
void desbloquearEdicaoAlarme(int alarmeId) {
  if (alarmeId >= 1 && alarmeId <= 6) {
    strcpy_P(textosAlarme[alarmeId - 1], PSTR(""));
    EEPROM.put(ADDR_TEXTO1 + (alarmeId - 1) * 100, textosAlarme[alarmeId - 1]);
    Serial.print(F("Edição do alarme "));
    Serial.print(alarmeId);
    Serial.println(F(" desbloqueada."));
  }
}
void ResetAlarme1() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 1"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *1*?", 0, -30);
}

void ResetAlarme2() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 2"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *2*?", 0, -30);
}

void ResetAlarme3() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 3"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *3*?", 0, -30);
}

void ResetAlarme4() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 4"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *4*?", 0, -30);
}

void ResetAlarme5() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 5"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto
  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *5*?", 0, -30);
}

void ResetAlarme6() {
  Serial.println(F("Janela: Confirmar o Reset do Alarme 6"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("O ALARME *6*?", 0, -30);
}

void ResetAll() {
  Serial.println(F("Janela: Confirmar o Reset de Todos os Alarmes"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto

  escreverTextoCentroSeguro("DESEJA DELETAR", 0, -90);
  escreverTextoCentroSeguro("*TODOS* OS ALARMES?", 0, -30);
}
void AllReset() {
  // 🔄 Zera todos os alarmes, textos e ciclos salvos
  for (int i = 1; i <= 6; i++) {
    salvarAlarme(i, false);  // Desativa o alarme

    // Limpa o texto correspondente
    textosAlarme[i - 1][0] = '\0';

    // Atualiza a EEPROM para garantir que o texto seja apagado permanentemente
    int enderecoTexto = ADDR_TEXTO1 + (i - 1) * 100;
    EEPROM.put(enderecoTexto, textosAlarme[i - 1]);

    // 🔁 Zera também o ciclo do alarme
    int enderecoCiclo = ADDR_CICLO_ALARME1 + (i - 1);
    EEPROM.update(enderecoCiclo, 0);
    definirCicloAlarme(i, 0);  // garante reset no runtime
  }

  // 🔓 Desbloqueia a edição de todos os alarmes
  for (int i = 1; i <= 6; i++) {
    desbloquearEdicaoAlarme(i);
  }

  Serial.println(F("Todos os alarmes, textos e ciclos foram resetados para 0 e desbloqueados."));
  Serial3.print(F("resetalarmeall"));
  deletarAlarme(1);
  deletarAlarme(2);
  deletarAlarme(3);
  deletarAlarme(4);
  deletarAlarme(5);
  deletarAlarme(6);
}

void ERRODEF() {
  Serial.println(F("Janela: ERRO de definição incorreta de um alarme, retornando a SCREEN_EDITOR em 5 segundos"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(RED);  // Cor do texto
  escreverTextoCentroSeguro("Alarme definido de", 0, -40);
  escreverTextoCentroSeguro("forma incorreta", 0, -10);
  tft.setTextColor(WHITE);  // Cor do texto
  escreverTextoCentroSeguro("Retornando ao Editor...", 0, +20);
  delay(3000);
  navigateToScreen(SCREEN_EDITOR);
  //adicionar bitmap de erro
}

void screeninfo() {
  Serial.println(F("Janela: Manual de Uso do Usuário - Página 1"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.setTextColor(WHITE);
  escreverTextoCentroSeguro1("MANUAL DE USO", 0, -110);
  escreverTextoCentroSeguro1("DO USUARIO", 0, -90);
  tft.fillRoundRect(35, 100, 190, 25, 2, AZURE);
  tft.setTextColor(BLACK);
  escreverTextoCentroSeguro1("Normas de Seguranca:", -110, -50);
  tft.setTextColor(WHITE);
  escreverTextoCentroSeguro1("1. Mantenha longe de campos eletromagneticos;", -10, -15);
  escreverTextoCentroSeguro1("2. A temperatura *deve* sinalizar:", -68, 20);
  tft.drawBitmap(320, 165, certo, 36, 36, GREEN);
  escreverTextoCentroSeguro1("3. Sempre conecte a uma fonte estavel.", -40, 55);
  desenharBotao(botoes[99]);
  desenharBotao(botoes[100]);
}
void screeninfo1() {
  Serial.println(F("Janela: Manual de Uso do Usuário - Página 2"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.setTextColor(WHITE);
  escreverTextoCentroSeguro1("MANUAL DE USO", 0, -110);
  escreverTextoCentroSeguro1("DO USUARIO", 0, -90);
    tft.fillRoundRect(35, 100, 320, 25, 2, AZURE);
  tft.setTextColor(BLACK);
  escreverTextoCentroSeguro1("Como definir um alarme corretamente:", -45, -50);
  tft.setTextColor(WHITE);
  escreverTextoCentroSeguro1("1. No menu inicial, acesse o edtior via >", -45, -15);
    tft.drawBitmap(370, 107, editor, 55, 55, WHITE);
  escreverTextoCentroSeguro1("2. Escolha um dos alarmes e clique em 'DEFINIR'.", -2, 20);
  escreverTextoCentroSeguro1("3. Na tela de definicao escolha o horario e ciclo.", -11, 45);
  escreverTextoCentroSeguro1("4. E *obrigatorio* definir um nome ao remedio.", -20, 65);
  desenharBotao(botoes[101]);
}
void screencalibracao() {
  Serial.println(F("Janela: Calibracão do RTC"));
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);
  tft.drawRGBBitmap(30, 30, back, 55, 55);
  tft.setTextColor(WHITE);
  //TEXTOS
  escreverTextoCentroSeguro1("CALIBRACAO DO", 0, -110);
  escreverTextoCentroSeguro1("RELOGIO", 0, -90);
  escreverTextoCentroSeguro("DIA", -150, -40);
  escreverTextoCentroSeguro("MES", -20, -40);
  escreverTextoCentroSeguro("ANO", +129, -40);
  escreverTextoCentroSeguro("HORA", -135, +53);
  escreverTextoCentroSeguro("MINUTO", +38, +53);
  //DIA
  tft.drawRoundRect(30, 145, 120, 40, 10, WHITE);
  desenharBotao(botoes[104]);
  desenharBotao(botoes[105]);
  //MÊS
  tft.drawRoundRect(160, 145, 120, 40, 10, WHITE);
  desenharBotao(botoes[106]);
  desenharBotao(botoes[107]);
  //ANO
  tft.drawRoundRect(290, 145, 160, 40, 10, WHITE);
  desenharBotao(botoes[108]);
  desenharBotao(botoes[109]);
  //HORA
  tft.drawRoundRect(50, 240, 120, 40, 10, WHITE);
  desenharBotao(botoes[110]);
  desenharBotao(botoes[111]);
  //MINUTO
  tft.drawRoundRect(220, 240, 120, 40, 10, WHITE);
  desenharBotao(botoes[112]);
  desenharBotao(botoes[113]);
  //OK
  desenharBotao(botoes[114]);
  desenharCamposRTC();
  atualizarEstadoScrollBotoes();  // 🔄 Atualiza travas dos botões após mudar o ano
}
void definirCicloAlarme(uint8_t id, uint8_t ciclo) {
  if (id < 1 || id > 6) return;                         // garante que o ID é válido
  cicloAlarme[id - 1] = ciclo;                          // salva na RAM
  EEPROM.update(ADDR_CICLO_ALARME1 + (id - 1), ciclo);  // salva na EEPROM

  Serial.print(F("Ciclo do alarme "));
  Serial.print(id);
  Serial.print(F(" definido para "));
  Serial.print(ciclo);
  Serial.println(F("h"));
}

void mostrarCicloAlarme(int id, int x, int y) {
  uint8_t ciclo = EEPROM.read(ADDR_CICLO_ALARME1 + (id - 1));

  tft.setTextColor(WHITE);
  tft.setTextSize(1);
  tft.setCursor(x, y);

  if (ciclo == 0) {
    tft.print(F("-"));  // Mostra apenas um traço se nenhum ciclo estiver definido
  } else {
    tft.print(ciclo);
    tft.print(F("H"));
  }
}

String obterTextoCiclo(int id) {
  uint8_t ciclo = EEPROM.read(ADDR_CICLO_ALARME1 + (id - 1));
  if (ciclo == 0) return F("");
  return String(ciclo) + F("H");
}
void definirBotaoTogglePressionado(int indiceBotaoReal, bool estado) {
  for (int i = 0; i < NUM_BOTOES; i++) {
    if (botoes[i].indice == indiceBotaoReal && botoes[i].toggle) {
      botoes[i].pressionado = estado;
      desenharBotao(botoes[i]);

      Serial.print(F("Toggle atualizado: índice "));
      Serial.print(indiceBotaoReal);
      Serial.print(F(" -> estado "));
      Serial.println(estado ? F("ATIVO") : F("INATIVO"));
      return;
    }
  }

  // Caso não encontre o botão — debug de segurança
  Serial.print(F("[ERRO] definirBotaoTogglePressionado: índice "));
  Serial.print(indiceBotaoReal);
  Serial.println(F(" não encontrado entre botoes[]."));
}


void resetToggleAlarme(int numeroTela, bool confirmar) {
  // Verifica se o número da tela é válido (1–6)
  if (numeroTela < 1 || numeroTela > 6) {
    Serial.println(F("⚠️ Número de tela inválido. Use de 1 a 6."));
    return;
  }

  // Se o reset não foi confirmado
  if (!confirmar) {
    Serial.print(F("❎ Reset do toggle da tela DEFAL"));
    Serial.print(numeroTela);
    Serial.println(F(" cancelado."));
    return;
  }

  int indiceTela = numeroTela - 1;
  int toggleAtivo = ultimoToggleAtivoPorTela[indiceTela];

  // Se não há toggle ativo, não faz nada
  if (toggleAtivo == -1) {
    Serial.print(F("ℹ️ Nenhum toggle ativo na tela DEFAL"));
    Serial.print(numeroTela);
    Serial.println(F(". Nada a resetar."));
    return;
  }

  // Desativa o toggle ativo
  for (int j = 0; j < NUM_BOTOES; j++) {
    if (botoes[j].indice == toggleAtivo) {
      botoes[j].pressionado = false;
      desenharBotao(botoes[j]);
      break;
    }
  }

  ultimoToggleAtivoPorTela[indiceTela] = -1;

  Serial.print(F("🔄 Toggle da tela DEFAL"));
  Serial.print(numeroTela);
  Serial.println(F(" foi resetado com sucesso."));
}

void resetarTogglesDefal() {
  for (int i = 0; i < 6; i++) {
    if (ultimoToggleAtivoPorTela[i] != -1) {
      int toggleAtivo = ultimoToggleAtivoPorTela[i];
      for (int j = 0; j < NUM_BOTOES; j++) {
        if (botoes[j].indice == toggleAtivo) {
          botoes[j].pressionado = false;
          desenharBotao(botoes[j]);
          break;
        }
      }
      ultimoToggleAtivoPorTela[i] = -1;
    }
  }
  Serial.println(F("🔁 Todos os toggles DEFAL foram resetados."));
}

// Função para redesenhar os textos de ciclo
void atualizarTextoCiclo(int indiceTela) {
  int numeros[] = { 6, 8, 12 };
  int posicoesX[] = { 78, 178, 266 };
  int posY = 276;

  for (int i = 0; i < 3; i++) {
    if (ultimoToggleAtivoPorTela[indiceTela] == numeros[i]) {
      tft.setTextColor(AZURE);  // ciclo ativo
    } else {
      tft.setTextColor(WHITE);  // ciclo inativo
    }
    tft.setCursor(posicoesX[i], posY);
    tft.setTextSize(2);
    tft.print(numeros[i]);
  }
}

int obterIndiceBotaoPorCiclo(int indiceTela, int ciclo) {
  int alvo = -1;
  for (int i = 0; i < NUM_BOTOES; i++) {
    if (!botaoPertenceATela(i)) continue;  // só considera os botões da tela atual
    Botao& b = botoes[i];
    if (!b.toggle) continue;

    if (indiceTela == 0 && ciclo == 6 && b.indice == 79) alvo = 79;
    else if (indiceTela == 0 && ciclo == 8 && b.indice == 80) alvo = 80;
    else if (indiceTela == 0 && ciclo == 12 && b.indice == 81) alvo = 81;

    // (Se quiser expandir para outras telas DEFAL2..DEFAL6, basta adicionar casos)
  }
  return alvo;
}
void drawScrollArea() {
  // fundo da área
  tft.fillRect(SCROLL_X, SCROLL_Y - 15, SCROLL_W, SCROLL_H + 10, WHITE);

  int yPos = SCROLL_Y;
  tft.setTextSize(1);

  int startLine = scrollOffset;

  for (int i = startLine; i < totalLinhas; i++) {
    if (yPos + lineHeight > SCROLL_Y + SCROLL_H) break;

    tft.setCursor(SCROLL_X + 5, yPos);
    tft.setTextColor(linhasScroll[i].cor);
    tft.print(linhasScroll[i].texto);

    yPos += lineHeight;
  }

  // ----- Barra de rolagem lateral -----
  int visibleLines = SCROLL_H / lineHeight;
  int barHeight = max((float)SCROLL_H * visibleLines / totalLinhas, 10);
  int barY = SCROLL_Y + ((float)scrollOffset / (totalLinhas - visibleLines)) * (SCROLL_H - barHeight);

  // canal
  tft.fillRect(SCROLL_X + SCROLL_W - 8, SCROLL_Y - 10, 8, SCROLL_H, DARKGREY);

  // barra
  tft.fillRect(SCROLL_X + SCROLL_W - 8, barY - 10, 8, barHeight, AZURE);
  tft.drawRect(SCROLL_X + SCROLL_W - 8, barY - 10, 8, barHeight, BLACK);
}

void resetarScroll() {
  scrollOffset = 0;
}

void atualizarEstadoScrollBotoes() {
  int visibleLines = SCROLL_H / lineHeight;

  bool podeSubirScroll = (scrollOffset > 0);
  bool podeDescerScroll = (scrollOffset < totalLinhas - visibleLines);

  for (int i = 0; i < NUM_BOTOES; i++) {

    Botao& btn = botoes[i];
    bool estadoAnterior = btn.ativo;

    // scroll cima (97)
    if (btn.indice == 97) {
      btn.ativo = !podeSubirScroll;
      btn.corNormal = podeSubirScroll ? BLACK : GREY;
    }

    // scroll baixo (98)
    if (btn.indice == 98) {
      btn.ativo = !podeDescerScroll;
      btn.corNormal = podeDescerScroll ? BLACK : GREY;
    }

    // --- NOVO: travar botões OK das telas DEFAL ---
    if (currentScreen >= SCREEN_DEFAL1 && currentScreen <= SCREEN_DEFAL6) {
      int okIndex = currentScreen - SCREEN_DEFAL1 + 6; // botões OK = 6..11

      if (btn.indice == okIndex) {
        btn.ativo = (tecladoAberto != 1);
        btn.corNormal = btn.ativo ? GREY : DARKGREY;
      }
    }

    if (btn.ativo != estadoAnterior)
      desenharBotao(btn);
  }
}



void atualizarMinutosRestantes() {
  int horaAtual = hour(RTC.get());
  int minutoAtual = minute(RTC.get());

  for (int i = 0; i < 6; i++) {
    byte h = horasAlarme[i];
    byte m = minutosAlarme[i];
    byte c = cicloAlarme[i];
    bool ativo = alarmeAtivo(i + 1);

    minutosRestantes[i] = calcularMinutosRestantes(h, m, c, horaAtual, minutoAtual, ativo);
  }
}

int calcularMinutosRestantes(byte horaAlarme, byte minutoAlarme, byte ciclo,
                             int horaAtual, int minutoAtual, bool ativo) {
  if (!ativo) return 99999;

  int minutosAtuais = horaAtual * 60 + minutoAtual;
  int minutosAlarme = horaAlarme * 60 + minutoAlarme;

  int diff = minutosAlarme - minutosAtuais;
  if (diff < 0) diff += 24 * 60;

  if (ciclo > 0) {
    int cicloMin = ciclo * 60;
    int resto = diff % cicloMin;
    return (resto == 0 ? 0 : resto);
  }

  return diff;
}

void gerarListaAlarmesOrdenados() {

  // BLOQUEIO SE RTC FALHOU (I2C) OU DESCALIBRADO
  if (!rtcDisponivel || !rtcCalibrado) {
    for (int i = 0; i < 6; i++) {
      int base = i * 3;
      linhasScroll[base] = { "Alarme " + String(i + 1), RED };
      linhasScroll[base + 1] = { "RTC FALHOU", BLACK };
      linhasScroll[base + 2] = { "----------------", DARKGREY };
      minutosRestantes[i] = 99999;
    }
    drawScrollArea();
    return;
  }

  carregarAlarmesDaEEPROM();

  time_t now = RTC.get();
  int horaAtual = hour(now);
  int minutoAtual = minute(now);

  agora1 = agora2 = agora3 = agora4 = agora5 = agora6 = false;

  struct AlarmeTmp {
    String nome;
    byte hora;
    byte minuto;
    byte ciclo;
    bool ativo;
    int indexOriginal;
    bool definido;
  } temp[6];

  for (int i = 0; i < 6; i++) {
    temp[i].nome = alarmes[i].nome;
    temp[i].hora = alarmes[i].hora;
    temp[i].minuto = alarmes[i].minuto;
    temp[i].ciclo = alarmes[i].ciclo;
    temp[i].ativo = alarmes[i].ativo;
    temp[i].indexOriginal = i;

    bool nomeVazio = (temp[i].nome.length() == 0);
    bool horaInvalida = (temp[i].hora > 23 || temp[i].minuto > 59);

    temp[i].definido = !(nomeVazio || horaInvalida || !temp[i].ativo);

    if (!temp[i].definido) {
      minutosRestantes[i] = 99999;
      continue;
    }

// SE FOI TOMADO – MAS EXPIRA DEPOIS DE 1 MINUTO
if (remedioTomado[i]) {

  // passou 1 minuto?
  if (millis() - tempoTomado[i] >= 60000) {
    remedioTomado[i] = 0;  // expira automaticamente
    // NÃO DÊ CONTINUE — deixar calcular o Agora!
  } else {
    // Ainda dentro do tempo de "Tomado"
    minutosRestantes[i] = 99998;  // prioridade
    // MAS AQUI SIM PODE SAIR → pois ainda é Tomado
    continue;
  }
}


    int minutosAtuais = horaAtual * 60 + minutoAtual;
    int minutosAlarme = temp[i].hora * 60 + temp[i].minuto;

    int diff = minutosAlarme - minutosAtuais;
    if (diff < 0) diff += 24 * 60;

    if (temp[i].ciclo > 0) {
      int cicloMin = temp[i].ciclo * 60;
      int rem = diff % cicloMin;
      minutosRestantes[i] = (rem == 0 ? 0 : rem);
    } else {
      minutosRestantes[i] = diff;
    }

    if (minutosRestantes[i] == 0) {
      switch (i) {
        case 0: agora1 = true; break;
        case 1: agora2 = true; break;
        case 2: agora3 = true; break;
        case 3: agora4 = true; break;
        case 4: agora5 = true; break;
        case 5: agora6 = true; break;
      }
    }
  }

  // ordenar definidos
  AlarmeTmp definidos[6], naoDefinidos[6];
  int dCount = 0, ndCount = 0;

  for (int i = 0; i < 6; i++) {
    if (temp[i].definido) definidos[dCount++] = temp[i];
    else naoDefinidos[ndCount++] = temp[i];
  }

  // Ordenação respeitando Tomado → Agora → restantes
  for (int a = 0; a < dCount - 1; a++) {
    for (int b = a + 1; b < dCount; b++) {

      int A = minutosRestantes[definidos[a].indexOriginal];
      int B = minutosRestantes[definidos[b].indexOriginal];

      if (B < A) {
        AlarmeTmp t = definidos[a];
        definidos[a] = definidos[b];
        definidos[b] = t;
      }
    }
  }

  // Remonta lista
  AlarmeTmp final[6];
  int idx = 0;

  for (int i = 0; i < dCount; i++) final[idx++] = definidos[i];
  for (int i = 0; i < ndCount; i++) final[idx++] = naoDefinidos[i];

  for (int i = 0; i < 6; i++) {
    int base = i * 3;

    if (!final[i].definido) {
      linhasScroll[base] = { "Alarme " + String(final[i].indexOriginal + 1) + " n/def.", RED };
      linhasScroll[base + 1] = { "--:--", BLACK };
      linhasScroll[base + 2] = { "----------------", DARKGREY };
      continue;
    }

    char horaStr[6];
    sprintf(horaStr, "%02d:%02d", final[i].hora, final[i].minuto);

    String segunda = String(horaStr);

    // (TOMADO)
    if (remedioTomado[final[i].indexOriginal]) {
      segunda += " (Tomado)";
    }
    // (AGORA)
    else if (minutosRestantes[final[i].indexOriginal] == 0) {
      segunda += " (Agora)";
    } else {
      int mr = minutosRestantes[final[i].indexOriginal];
      int h = mr / 60;
      int m = mr % 60;

      if (mr != 99999) {
        if (h == 0) segunda += " (" + String(m) + "m)";
        else if (m == 0) segunda += " (" + String(h) + "h)";
        else segunda += " (" + String(h) + "h" + String(m) + "m)";
      }
    }

    linhasScroll[base] = { limitarTexto(final[i].nome.c_str(), 11), RED };
    linhasScroll[base + 1] = { segunda, BLACK };
    linhasScroll[base + 2] = { "----------------", DARKGREY };
  }

  drawScrollArea();
}


void desenharCamposRTC() {
  tft.setTextColor(WHITE);
  tft.setTextSize(1);

  // DIA
  tft.fillRect(70, 146, 39, 38, BLACK);
  char buffer[6];
  sprintf(buffer, "%02d", rtcDia);
  tft.setCursor(80, 170);  // ↓ abaixado em 5 px
  tft.print(buffer);

  // MÊS
  tft.fillRect(200, 146, 39, 38, BLACK);
  sprintf(buffer, "%02d", rtcMes);
  tft.setCursor(210, 170);
  tft.print(buffer);

  // ANO
  tft.fillRect(330, 146, 79, 38, BLACK);
  sprintf(buffer, "%04d", rtcAno);
  tft.setCursor(350, 170);
  tft.print(buffer);

  // HORA
  tft.fillRect(90, 241, 39, 38, BLACK);
  sprintf(buffer, "%02d", rtcHora);
  tft.setCursor(103, 265);
  tft.print(buffer);

  // MINUTO
  tft.fillRect(260, 241, 39, 38, BLACK);
  sprintf(buffer, "%02d", rtcMin);
  tft.setCursor(270, 265);
  tft.print(buffer);
}

void corrigirDataRTC() {
  if (rtcMes < 1) rtcMes = 12;
  else if (rtcMes > 12) rtcMes = 1;

  if (rtcAno < 2025) rtcAno = 2025;
  else if (rtcAno > 2049) rtcAno = 2025;

  int maxDia = diasNoMes(rtcMes, rtcAno);
  if (rtcDia < 1) rtcDia = maxDia;
  else if (rtcDia > maxDia) rtcDia = 1;
}

void salvarCalibracaoRTC() {
  // ✅ Garante que os valores estejam dentro dos limites corretos
  if (rtcMes < 1) rtcMes = 1;
  if (rtcMes > 12) rtcMes = 12;
  if (rtcDia < 1) rtcDia = 1;

  // Ajusta automaticamente o dia máximo do mês
  int diasNoMes;
  switch (rtcMes) {
    case 4:
    case 6:
    case 9:
    case 11: diasNoMes = 30; break;
    case 2:  // Fevereiro — ano bissexto?
      diasNoMes = ((rtcAno % 4 == 0 && rtcAno % 100 != 0) || (rtcAno % 400 == 0)) ? 29 : 28;
      break;
    default: diasNoMes = 31;
  }
  if (rtcDia > diasNoMes) rtcDia = diasNoMes;

  if (rtcHora > 23) rtcHora = 23;
  if (rtcMin > 59) rtcMin = 59;

  // 🕒 Cria o novo horário baseado nas variáveis ajustadas
  setTime(rtcHora, rtcMin, 0, rtcDia, rtcMes, rtcAno);

  // 💾 Grava o horário no RTC físico
  RTC.set(now());

  // 🌡️ Reinicia a onda quadrada para garantir sincronismo
  RTC.squareWave(DS3232RTC::SQWAVE_1_HZ);

  rtcCalibrado = true;
  Serial.println(F("RTC calibrado — alarmes liberados."));
}

void deletarAlarme(int alarme) {
  if (alarme < 0 || alarme >= 6) return;

  // --- Resetar hora, minuto, ciclo ---
  EEPROM.write(ADDR_HORA1 + alarme * 10, 0);
  EEPROM.write(ADDR_MIN1 + alarme * 10, 0);
  EEPROM.write(ADDR_CICLO_ALARME1 + alarme, 0);

  // --- Resetar RAM (CORREÇÃO CRÍTICA) ---
  horasAlarme[alarme] = 0;
  minutosAlarme[alarme] = 0;
  cicloAlarme[alarme] = 0;

  // --- Resetar nome ---
  char vazio[100] = { 0 };
  EEPROM.put(ADDR_TEXTO1 + alarme * 100, vazio);
  textosAlarme[alarme][0] = '\0';

  minutosRestantes[alarme] = 99999;

  Serial.print(F("✅ Alarme "));
  Serial.print(alarme + 1);
  Serial.println(F(" deletado e resetado."));
}

void processarAlarme(int numAlarme) {
  // numAlarme está vindo de 1 a 6 — converter para índice 0–5
  int idx = numAlarme - 1;

  if (alarmeEditando == numAlarme && tecladoAberto == 1 && podeSalvarAlarme(numAlarme)) {

    // --------------------------------------
    // ✔ SALVAR ALARME (ATIVO = true)
    // --------------------------------------
    salvarAlarme(numAlarme, true);

    // ✔ Atualizar RAM imediatamente (CORREÇÃO CRÍTICA)
    horasAlarme[idx] = EEPROM.read(ADDR_HORA1 + idx * 10);
    minutosAlarme[idx] = EEPROM.read(ADDR_MIN1 + idx * 10);
    cicloAlarme[idx] = EEPROM.read(ADDR_CICLO_ALARME1 + idx);

    Serial.print(F("✅ DEFINIR ALARME "));
    Serial.print(numAlarme);
    Serial.println(F(" — salvo com sucesso"));

    Serial3.print("alarme" + String(numAlarme) + "def");
    navigateToScreen(SCREEN_EDITOR);
  } else {

    // --------------------------------------
    // ❌ FALHA AO SALVAR
    // --------------------------------------
    salvarAlarme(numAlarme, false);

    Serial.print(F("❌ Erro: Alarme "));
    Serial.print(numAlarme);
    Serial.println(F(" não definido — conflito ou RTC inválido"));
    Serial3.print(F("errodef"));
    navigateToScreen(SCREEN_ERRODEF);

    // Resetar nome e ciclo
    textosAlarme[idx][0] = '\0';
    definirCicloAlarme(numAlarme, 0);

    // Desbloquear edição
    desbloquearEdicaoAlarme(numAlarme);
  }

  // Resetar flag de edição
  alarmeEditando = 0;
}

void screenalarmetocando(int idAlarme) {
  if (idAlarme < 0 || idAlarme > 5) return;

  // ======================================================
  // 1) Seleção automática de pinos do alarme
  // ======================================================
  int reedPin = 0;
  int ledPin = 0;

  switch (idAlarme) {
    case 0:
      reedPin = reedPin1;
      ledPin = ledPin1;
      break;
    case 1:
      reedPin = reedPin2;
      ledPin = ledPin2;
      break;
    case 2:
      reedPin = reedPin3;
      ledPin = ledPin3;
      break;
    case 3:
      reedPin = reedPin4;
      ledPin = ledPin4;
      break;
    case 4:
      reedPin = reedPin5;
      ledPin = ledPin5;
      break;
    case 5:
      reedPin = reedPin6;
      ledPin = ledPin6;
      break;
  }

  pinMode(reedPin, INPUT);
  pinMode(ledPin, OUTPUT);

  // LED começa ligado
  ledLigado = true;
  aplicarEstadoLED(ledPin);

  carregarAlarmesDaEEPROM();
  AlarmeInfo atual = alarmesInfo[idAlarme];

  // Certifica-se de usar o flag global para este alarme (limpa ao entrar)
  remedioTomado[idAlarme] = false;

  Serial.println(F("Janela: Alarme Tocando"));
  Serial3.print("alarmetocando");
  tft.fillScreen(WHITE);
  tft.drawRoundRect(10, 10, 460, 300, 10, BLACK);
  tft.fillRoundRect(20, 20, 440, 280, 10, BLACK);

  // ======================================================
  // CONTAGEM REGRESSIVA CONTROLADA
  // ======================================================

  const unsigned long duracaoContagem = 1UL * 60UL * 1000UL;

  unsigned long inicioContagem = millis();
  unsigned long tempoPausado = 0;
  bool pausaContagem = false;  // ➜ Congela para sempre após abrir

  unsigned long ultimoBlink = millis();
  const unsigned long piscInterval = 1000UL;
  bool piscState = false;

  bool compartimentoAberto = false;
  // removido bool local remedioTomado; usamos apenas o array global remedioTomado[idAlarme]

  int ultimoUpdateSeg = -1;
  bool textoRetanguloTravado = false;


  // ----------------------------------
  // Retângulo + texto
  // ----------------------------------
  auto atualizarRetanguloETexto = [&](bool piscando) {
    uint16_t fillCor;

    if (compartimentoAberto)
      fillCor = atual.corLed;
    else if (remedioTomado[idAlarme])
      fillCor = DARKGREY;
    else
      fillCor = piscando ? atual.corLed : DARKGREY;

    tft.fillRoundRect(90, 210, 300, 70, 10, fillCor);
    tft.drawRoundRect(90, 210, 300, 70, 10, WHITE);

    if (!textoRetanguloTravado)
      tft.setTextColor(piscando ? WHITE : BLACK);
    else if (compartimentoAberto)
      tft.setTextColor(WHITE);
    else if (remedioTomado[idAlarme])
      tft.setTextColor(BLACK);

    if (!textoRetanguloTravado || compartimentoAberto || remedioTomado[idAlarme])
      escreverTextoCentroSeguro("ALARME " + String(atual.id), 0, +80);
  };


  // ----------------------------------
  // Layout inicial
  // ----------------------------------
  auto desenharBase = [&]() {
    atualizarRetanguloETexto(true);

    tft.setTextColor(GREY);
    escreverTextoCentroSeguro1("TEMPO RESTANTE:", -40, -110);

    tft.setTextColor(WHITE);
    escreverTextoCentroSeguro("HORA DO REMEDIO:", 0, -70);

    {
      String textoExibido = limitarTexto(atual.nome.c_str(), 16);
      int16_t x1, y1;
      uint16_t w, h;
      tft.setTextSize(2);
      tft.getTextBounds(textoExibido, 0, 0, &x1, &y1, &w, &h);
      int16_t cx = tft.width() / 2;
      int16_t cy = tft.height() / 2 - 16;
      tft.fillRoundRect(cx - w / 2 - 9, cy - h / 2 - 14, w + 23, h + 23, 3, WHITE);
      tft.setTextColor(atual.corLed);
      tft.setCursor(cx - w / 2, cy - h / 2 + 20);
      tft.print(textoExibido);
    }

    tft.setTextColor(WHITE);
    escreverTextoCentroSeguro1("Abra o compartimento que estiver sinalizado.", 0, +25);
  };

  desenharBase();


  // ==================================================================
  //                          LOOP PRINCIPAL
  // ==================================================================
  while (currentScreen == SCREEN_ALARMETOCANDO) {
    unsigned long agora = millis();


    // ---------------------------------------------------------
    // LED pisca enquanto não abriu
    // ---------------------------------------------------------
    if (!remedioTomado[idAlarme] && !compartimentoAberto && (agora - ultimoBlink >= piscInterval)) {
      ultimoBlink = agora;
      piscState = !piscState;

      ledLigado = piscState;
      aplicarEstadoLED(ledPin);

      atualizarRetanguloETexto(piscState && !textoRetanguloTravado);
    }


    // ---------------------------------------------------------
    // CONTAGEM REGRESSIVA (com pausa PERMANENTE ao abrir)
    // ---------------------------------------------------------
    unsigned long elapsed;

    if (!pausaContagem)
      elapsed = (millis() - inicioContagem) + tempoPausado;
    else
      elapsed = tempoPausado;  // congelado para sempre

    if (elapsed >= duracaoContagem) {
      // Tempo acabou ANTES da tampa abrir
      tft.fillRoundRect(40, 176, 400, 26, 10, BLACK);
      String textoExibido = "Alarme perdido, retornando ao Inicio.";
      int16_t x1, y1;
      uint16_t w, h;
      tft.setTextSize(1);
      tft.getTextBounds(textoExibido, 0, 0, &x1, &y1, &w, &h);
      int16_t cx = tft.width() / 2;
      int16_t cy = tft.height() / 2 + 42;
      tft.fillRoundRect(cx - w / 2 - 3, cy - h / 2 - 18, w + 8, h + 10, 3, DARKGREY);
      tft.setTextColor(RED);
      tft.setCursor(cx - w / 2, cy - h / 2);
      tft.print(textoExibido);

      ledLigado = false;
      aplicarEstadoLED(ledPin);
      delay(200);
      Serial3.print("paredevibrar");
      delay(4000);

      navigateToScreen((AppScreen)telaOrigem);
      currentScreen = (AppScreen)telaOrigem;
      return;
    } else {
      if (!pausaContagem) {
        int restanteS = (duracaoContagem - elapsed) / 1000;
        if (restanteS != ultimoUpdateSeg) {
          ultimoUpdateSeg = restanteS;
          int m = restanteS / 60;
          int s = restanteS % 60;
          char buf[6];
          sprintf(buf, "%02d:%02d", m, s);
          tft.fillRoundRect(285, 35, 50, 40, 10, BLACK);
          tft.setTextColor(GREY);
          escreverTextoCentroSeguro1(String(buf), +69, -110);
        }
      }
    }


    // ---------------------------------------------------------
    // Reed Switch
    // ---------------------------------------------------------
    int reedState = leituraReedDebounced(reedPin);


    // ---------------------------------------------------------
    // TAMPA ABRIU → PAUSA DEFINITIVA
    // ---------------------------------------------------------
    if (reedState == LOW && !compartimentoAberto && !remedioTomado[idAlarme]) {
      compartimentoAberto = true;
      textoRetanguloTravado = true;

      pausaContagem = true;  // PAUSA PARA SEMPRE
      tempoPausado = (millis() - inicioContagem) + tempoPausado;

      tft.fillRoundRect(40, 176, 400, 26, 10, BLACK);

      ledLigado = true;
      aplicarEstadoLED(ledPin);
      delay(200);
      Serial3.print("paredevibrar");

      atualizarRetanguloETexto(false);

      String textoExibido = "Compartimento aberto, tome e feche a tampa.";
      int16_t x1, y1;
      uint16_t w, h;
      tft.setTextSize(1);
      tft.getTextBounds(textoExibido, 0, 0, &x1, &y1, &w, &h);
      int16_t cx = tft.width() / 2;
      int16_t cy = tft.height() / 2 + 42;
      tft.fillRoundRect(cx - w / 2 - 3, cy - h / 2 - 18, w + 8, h + 10, 3, DARKGREY);
      tft.setTextColor(atual.corLed);
      tft.setCursor(cx - w / 2, cy - h / 2);
      tft.print(textoExibido);
    }


    // ---------------------------------------------------------
    // TAMPA FECHOU → FINALIZAR
    // ---------------------------------------------------------
    if (reedState == HIGH && compartimentoAberto && !remedioTomado[idAlarme]) {
      // marca local + global (global usado pela lista)
      remedioTomado[idAlarme] = true;
      compartimentoAberto = false;

      tft.fillRoundRect(40, 176, 400, 26, 10, BLACK);

      ledLigado = false;
      aplicarEstadoLED(ledPin);

      atualizarRetanguloETexto(false);

      String textoExibido = "Remedio tomado, retornando ao Inicio";
      int16_t x1, y1;
      uint16_t w, h;
      tft.setTextSize(1);
      tft.getTextBounds(textoExibido, 0, 0, &x1, &y1, &w, &h);
      int16_t cx = tft.width() / 2;
      int16_t cy = tft.height() / 2 + 42;
      tft.fillRoundRect(cx - w / 2 - 3, cy - h / 2 - 18, w + 8, h + 10, 3, DARKGREY);
      tft.setTextColor(GREEN);
      tft.setCursor(cx - w / 2, cy - h / 2);
      tft.print(textoExibido);

      delay(4000);
      navigateToScreen((AppScreen)telaOrigem);
      currentScreen = (AppScreen)telaOrigem;
      return;
    }
  }
}
void aplicarEstadoLED(int ledPin) {
  digitalWrite(ledPin, ledLigado ? HIGH : LOW);
}

void checarAlarmesAgora() {

  // BLOQUEIOS NOVOS
  if (!rtcDisponivel || !rtcCalibrado) return;
  if (currentScreen == SCREEN_CALIBRACAO) return;
  if (currentScreen == SCREEN_ALARMETOCANDO) return;

  bool agoraFlags[6] = { agora1, agora2, agora3, agora4, agora5, agora6 };

  for (int i = 0; i < 6; i++) {

    // IGNORA alarmes já tomados
    if (remedioTomado[i]) continue;

    // DISPARO
    if (agoraFlags[i] && !alarmeBloqueado[i]) {

      alarmeTocando = i;
      remedioTomado[i] = false;  // garantir reset
      navigateToScreen(SCREEN_ALARMETOCANDO);
      alarmeBloqueado[i] = true;
      return;
    }

    // libera quando saiu do AGORA
    if (!agoraFlags[i]) {
      alarmeBloqueado[i] = false;
    }
  }
}
void atualizarTempoEAgora() {

  // BLOQUEIO TOTAL
  if (!rtcDisponivel || !rtcCalibrado) {
    agora1 = agora2 = agora3 = agora4 = agora5 = agora6 = false;
    return;
  }

  // BLOQUEIO DA TELA DE CALIBRAÇÃO
  if (currentScreen == SCREEN_CALIBRACAO) {
    agora1 = agora2 = agora3 = agora4 = agora5 = agora6 = false;
    return;
  }

  time_t now = RTC.get();
  horaAtualGlobal = hour(now);
  minutoAtualGlobal = minute(now);

  for (int i = 0; i < 6; i++) {

    if (!alarmes[i].ativo) {
      switch (i) {
        case 0: agora1 = false; break;
        case 1: agora2 = false; break;
        case 2: agora3 = false; break;
        case 3: agora4 = false; break;
        case 4: agora5 = false; break;
        case 5: agora6 = false; break;
      }
      continue;
    }

    bool ehAgora = (!remedioTomado[i] && alarmes[i].hora == horaAtualGlobal && alarmes[i].minuto == minutoAtualGlobal);

    switch (i) {
      case 0: agora1 = ehAgora; break;
      case 1: agora2 = ehAgora; break;
      case 2: agora3 = ehAgora; break;
      case 3: agora4 = ehAgora; break;
      case 4: agora5 = ehAgora; break;
      case 5: agora6 = ehAgora; break;
    }
  }
}

void marcarComoTomado(int i) {
  remedioTomado[i] = 1;
  tempoTomado[i] = millis();   // só isso
}